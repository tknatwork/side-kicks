<!--
  ☕️ Variables & Styles Extractor - Figma Plugin v2.0.0
  Export and import Figma variables and styles with full fidelity
  
  Copyright (c) 2025 Tushar Kant Naik / The Keep Collective
  Licensed under MIT - See LICENSE file
  
  Author: Tushar Kant Naik <hi@tusharkantnaik.com>
  Website: https://tusharkantnaik.com
  
  v2.0.0: Wide 4-column layout (1200×628px)
  Design: Neo-brutalist + HIG spacing principles
-->
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/css2?family=Cookie&display=swap" rel="stylesheet">
  <title>Variables and Styles Extractor v2.0.0</title>
  <style>
    /* ==========================================================================
       VARIABLES EXTRACTOR v2.0.0 - NEO-BRUTALIST DESIGN SYSTEM
       
       Layout (from Figma):
       - Content: 1200×628px (Figma title bar is separate 52px)
       - Header: 56px centered tab switcher
       - Body: 500px with 4 columns (16px gaps)
       - Footer: 72px branding
       
       Style: Neo-brutalist (sharp corners, bold borders, offset shadows)
       Spacing: HIG 8pt grid system
       ========================================================================== */

    :root {
      /* === Colors - Bold neo-brutalist palette === */
      --color-bg: #FFFFFF;
      --color-bg-secondary: #F5F5F5;
      --color-bg-tertiary: #EBEBEB;
      --color-surface: #FFFFFF;
      
      /* Borders - Bold black for neo-brutalist look */
      --color-border: #000000;
      --color-border-column: #000000;
      --color-border-footer: #000000;
      
      /* Text */
      --color-text: #000000;
      --color-text-secondary: #666666;
      --color-text-tertiary: #999999;
      
      /* Semantic */
      --color-primary: #FF90E8;
      --color-primary-hover: #FF6EDE;
      --color-success: #52C41A;
      --color-warning: #FAAD14;
      --color-error: #FF4D4F;
      --color-info: #1890FF;
      
      /* Type badges */
      --color-color: #9B59B6;
      --color-number: #3498DB;
      --color-boolean: #E67E22;
      --color-string: #27AE60;

      /* === Layout dimensions === */
      --plugin-width: 1200px;
      --plugin-height: 628px;
      --header-height: 56px;
      --body-height: 500px;
      --footer-height: 72px;
      --body-padding: 16px;
      --column-gap: 16px;
      
      /* Column dimensions */
      --col1-width: 279px;
      --col2-width: 280px;
      --col3-width: 280px;
      --col4-width: 279px;
      --column-height: 468px;

      /* === 8pt Grid Spacing === */
      --space-xs: 4px;
      --space-sm: 8px;
      --space-md: 12px;
      --space-lg: 16px;
      --space-xl: 24px;
      
      /* === Border & Radius - Neo-brutalist (minimal rounding) === */
      --border-width: 2px;
      --border-radius: 4px;
      
      /* === Shadows - Bold offset (neo-brutalist) === */
      --shadow: 3px 3px 0px 0px #000000;
      --shadow-hover: 5px 5px 0px 0px #000000;
      --shadow-active: 1px 1px 0px 0px #000000;

      /* === Typography === */
      --font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      --font-mono: 'Monaco', 'Menlo', monospace;
    }

    /* === Reset === */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    /* === Performance Optimizations === */
    .column-body {
      contain: layout style;
      will-change: scroll-position;
    }
    
    .column-body-with-fade {
      contain: layout style;
    }
    
    /* Hardware-accelerated scrolling */
    .column-body,
    .column-body-with-fade,
    .import-preview-content,
    .log-entries {
      -webkit-overflow-scrolling: touch;
      transform: translateZ(0);
    }
    
    /* Reduce paint complexity for animated elements */
    .skeleton-item,
    .btn,
    .form-checkbox,
    .accordion-arrow {
      will-change: opacity, transform;
    }
    
    /* Content visibility for off-screen optimization */
    .hidden {
      content-visibility: hidden;
    }

    /* === Base Body === */
    body {
      font-family: var(--font-family);
      font-size: 12px;
      line-height: 1.5;
      color: var(--color-text);
      background: var(--color-bg);
      width: var(--plugin-width);
      height: var(--plugin-height);
      overflow: visible;
      display: flex;
      flex-direction: column;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* ==========================================================================
       LAYOUT STRUCTURE - Header, Body (4-col), Footer
       ========================================================================== */

    /* === Header: 56px, centered tab switcher === */
    .plugin-header {
      height: var(--header-height);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 var(--space-lg);
      background: var(--color-bg);
      flex-shrink: 0;
      border-bottom: var(--border-width) solid var(--color-border);
    }

    /* User Mode Toggle Styles */
    .user-mode-toggle {
      display: flex;
      align-items: center;
      background: var(--color-bg-secondary);
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      padding: 3px;
      gap: 0;
    }

    .user-mode-toggle input[type="radio"] {
      display: none;
    }

    .user-mode-toggle .mode-label {
      padding: 6px 14px;
      font-size: 11px;
      font-weight: 600;
      color: var(--color-text-secondary);
      cursor: pointer;
      border-radius: 2px;
      transition: all 0.15s ease;
    }

    .user-mode-toggle .mode-label:hover {
      color: var(--color-text);
    }

    .user-mode-toggle input[type="radio"]:checked + .mode-label {
      background: #90EE90;
      color: var(--color-text);
    }

    /* Simple/Advanced Mode Visibility */
    .advanced-only {
      display: none !important;
    }
    body.advanced-mode .advanced-only {
      display: flex !important;
    }
    /* For block-level elements */
    .advanced-only-block {
      display: none;
    }
    body.advanced-mode .advanced-only-block:not(.is-hidden) {
      display: block;
    }

    /* Spacer to balance header */
    .header-spacer {
      width: 140px;
    }

    /* Import Behavior Toggle */
    .import-behavior-toggle {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .behavior-option {
      display: flex;
      align-items: center;
      padding: 8px 10px;
      background: var(--color-bg);
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .behavior-option:hover {
      background: var(--color-bg-tertiary);
    }

    .behavior-option input[type="radio"] {
      margin-right: 10px;
      width: 14px;
      height: 14px;
      cursor: pointer;
    }

    .behavior-option input[type="radio"]:checked + .behavior-content .behavior-name {
      color: var(--color-text);
    }

    .behavior-option:has(input:checked) {
      background: #E8F5E9;
      border-color: #4CAF50;
    }

    .behavior-content {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .behavior-name {
      font-size: 11px;
      font-weight: 600;
      color: var(--color-text);
    }

    .behavior-desc {
      font-size: 9px;
      color: var(--color-text-secondary);
    }

    /* Import Diff Preview Styles */
    .diff-summary {
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }
    .diff-row {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
      padding: 6px 8px;
      background: var(--color-bg);
      border-radius: var(--border-radius);
      border: 1px solid var(--color-border);
    }
    .diff-label {
      font-size: 9px;
      color: var(--color-text-secondary);
    }
    .diff-count {
      font-size: 16px;
      font-weight: 700;
      color: #4CAF50;
    }
    .diff-count.diff-modified {
      color: #FF9800;
    }
    .diff-count.diff-unchanged {
      color: var(--color-text-secondary);
    }
    .diff-details summary {
      padding: 4px 0;
      color: var(--color-text-secondary);
    }
    .diff-details summary:hover {
      color: var(--color-text);
    }
    .diff-list {
      padding-left: 12px;
    }
    .diff-item {
      padding: 2px 0;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .diff-item.new { color: #4CAF50; }
    .diff-item.modified { color: #FF9800; }
    .diff-item.unchanged { color: var(--color-text-secondary); }
    .diff-value-change {
      font-size: 9px;
      color: var(--color-text-tertiary);
      font-family: var(--font-mono);
    }

    /* Export Options Accordion */
    .export-options-accordion {
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius);
      background: var(--color-bg-secondary);
      margin-bottom: 8px;
      overflow: hidden;
    }
    .export-options-summary {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      cursor: pointer;
      font-size: 11px;
      font-weight: 600;
      color: var(--color-text);
      user-select: none;
    }
    .export-options-summary:hover {
      background: var(--color-bg-tertiary);
    }
    .export-options-accordion[open] .export-options-summary {
      border-bottom: 1px solid var(--color-border);
    }
    .export-options-accordion[open] .accordion-arrow {
      transform: rotate(180deg);
    }
    .accordion-arrow {
      font-size: 10px;
      color: var(--color-text-secondary);
      transition: transform 0.2s ease;
    }
    .export-options-content {
      padding: 8px 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .export-options-content .footer-option {
      margin: 0;
    }

    /* Plan Accordion Styles */
    .plan-accordion {
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius);
      background: var(--color-bg);
      overflow: hidden;
    }
    .plan-accordion-summary {
      display: flex;
      align-items: center;
      padding: 10px 12px;
      cursor: pointer;
      user-select: none;
    }
    .plan-accordion-summary:hover {
      background: var(--color-bg-tertiary);
    }
    .plan-accordion-header {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1;
    }
    .plan-accordion-header .plan-icon {
      font-size: 18px;
    }
    .plan-accordion-header .plan-info {
      display: flex;
      flex-direction: column;
    }
    .plan-accordion-header .plan-label {
      font-size: 10px;
      color: var(--color-text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    .plan-accordion-header .plan-value {
      font-size: 13px;
      font-weight: 600;
      color: var(--color-text);
    }
    .plan-accordion[open] .plan-accordion-summary {
      border-bottom: 1px solid var(--color-border);
    }
    .plan-accordion[open] .accordion-arrow {
      transform: rotate(180deg);
    }
    .plan-accordion-content {
      padding: 10px 12px;
      background: var(--color-bg-secondary);
    }
    .plan-modes-info {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .plan-modes-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 8px;
      border-radius: var(--border-radius);
      font-size: 11px;
    }
    .plan-modes-row:hover {
      background: var(--color-bg);
    }
    .plan-modes-row.current-plan {
      background: #E6F4EA;
      border: 1px solid #34A853;
    }
    .plan-modes-row .plan-name {
      font-weight: 500;
    }
    .plan-modes-row .plan-modes-count {
      color: var(--color-text-secondary);
      font-size: 10px;
    }
    .plan-accordion-note {
      font-size: 10px;
      color: var(--color-text-secondary);
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid var(--color-border);
    }

    /* Plan Compatibility Banner */
    .compatibility-banner {
      padding: 10px 12px;
      border-radius: var(--border-radius);
      border: 1px solid var(--color-border);
      background: var(--color-bg);
    }
    .compatibility-status {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .compatibility-icon {
      font-size: 16px;
    }
    .compatibility-text {
      font-size: 12px;
      font-weight: 600;
    }
    .compatibility-detail {
      font-size: 10px;
      color: var(--color-text-secondary);
      margin-top: 4px;
      margin-left: 24px;
    }
    .compatibility-banner.compatible {
      background: #E6F4EA;
      border-color: #34A853;
    }
    .compatibility-banner.incompatible {
      background: #FFF3CD;
      border-color: #FFC107;
    }
    .compatibility-banner.error {
      background: #FFEBEE;
      border-color: #F44336;
    }

    /* Import Preview Accordion */
    .import-preview-accordion {
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius);
      background: var(--color-bg);
      overflow: hidden;
    }
    .import-preview-summary {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 12px;
      cursor: pointer;
      font-size: 11px;
      font-weight: 600;
      user-select: none;
    }
    .import-preview-summary:hover {
      background: var(--color-bg-tertiary);
    }
    .preview-summary-counts {
      flex: 1;
      text-align: right;
      font-size: 10px;
      font-weight: 400;
      color: var(--color-text-secondary);
    }
    .import-preview-accordion[open] .import-preview-summary {
      border-bottom: 1px solid var(--color-border);
    }
    .import-preview-accordion[open] .accordion-arrow {
      transform: rotate(180deg);
    }
    .import-preview-content {
      padding: 10px 12px;
      max-height: 200px;
      overflow-y: auto;
    }

    /* Import Behavior Footer Accordion */
    .import-behavior-accordion {
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius);
      background: var(--color-bg-secondary);
      overflow: hidden;
    }
    .import-behavior-summary {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      cursor: pointer;
      font-size: 11px;
      font-weight: 600;
      user-select: none;
    }
    .import-behavior-summary:hover {
      background: var(--color-bg-tertiary);
    }
    .import-behavior-accordion[open] .import-behavior-summary {
      border-bottom: 1px solid var(--color-border);
    }
    .import-behavior-accordion[open] .accordion-arrow {
      transform: rotate(180deg);
    }
    .import-behavior-content {
      padding: 8px 10px;
    }

    /* Load JSON section expands in Simple mode */
    #load-json-section {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    #load-json-section #import-input-container {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    #load-json-section #import-input {
      flex: 1;
      min-height: 140px;
    }
    
    /* Column body wrapper for scroll fade containment */
    .column-body-wrapper {
      position: relative;
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }
    .column-body-wrapper .column-body {
      flex: 1;
      min-height: 0;
    }
    .column-body-wrapper .column-scroll-fade-top,
    .column-body-wrapper .column-scroll-fade-bottom {
      position: absolute;
      left: 0;
      right: 0;
      height: 24px;
      pointer-events: none;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    .column-body-wrapper .column-scroll-fade-top {
      top: 0;
      background: linear-gradient(to bottom, rgba(0,0,0,0.27) 0%, rgba(0,0,0,0) 100%);
    }
    .column-body-wrapper .column-scroll-fade-bottom {
      bottom: 0;
      background: linear-gradient(to top, rgba(0,0,0,0.27) 0%, rgba(0,0,0,0) 100%);
    }
    /* Reset previous import-input-fade-bottom positioning */
    #import-input-fade-bottom {
      bottom: 0;
    }

    /* Per-collection behavior dropdown (Advanced mode) */
    .collection-behavior-dropdown {
      font-size: 10px;
      padding: 2px 6px;
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius);
      background: var(--color-bg);
      cursor: pointer;
      margin-left: auto;
    }

    .collection-behavior-dropdown:focus {
      outline: none;
      border-color: var(--color-primary);
    }

    /* Collection item with advanced controls */
    .collection-item-advanced {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
    }

    .collection-item-advanced .collection-info {
      flex: 1;
      min-width: 0;
    }

    .collection-item-advanced .collection-behavior-dropdown {
      margin-top: 4px;
      flex-shrink: 0;
    }

    /* NEW badge for collections that don't exist in target */
    .collection-new-badge {
      display: inline-block;
      font-size: 9px;
      font-weight: 700;
      color: #fff;
      background: #4CAF50;
      padding: 1px 5px;
      border-radius: 3px;
      margin-left: 6px;
      vertical-align: middle;
      letter-spacing: 0.5px;
    }

    /* Naming Convention Dropdown */
    .naming-convention-row {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
    }

    .naming-label {
      font-size: 11px;
      font-weight: 500;
      color: var(--color-text-secondary);
      white-space: nowrap;
    }

    .naming-dropdown {
      flex: 1;
      padding: 6px 10px;
      font-size: 11px;
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius);
      background: var(--color-bg);
      cursor: pointer;
    }

    .naming-dropdown:focus {
      outline: none;
      border-color: var(--color-primary);
    }

    /* Advanced mode indicator */
    .advanced-only {
      display: none;
    }

    body.advanced-mode .advanced-only {
      display: block;
    }

    .collection-item-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .collection-item-row .form-checkbox {
      flex: 1;
    }

    .tab-switcher {
      display: flex;
      background: var(--color-bg-secondary);
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      padding: 0;
      gap: 0;
      overflow: hidden;
    }

    .tab-btn {
      padding: 10px 28px;
      font-size: 12px;
      font-weight: 600;
      color: var(--color-text-secondary);
      background: var(--color-bg-secondary);
      border: none;
      border-right: var(--border-width) solid var(--color-border);
      cursor: pointer;
      transition: all 0.1s ease;
      min-width: 110px;
    }

    .tab-btn:first-child {
      border-radius: var(--border-radius) 0 0 var(--border-radius);
    }

    .tab-btn:last-child {
      border-right: none;
      border-radius: 0 var(--border-radius) var(--border-radius) 0;
    }

    .tab-btn:hover {
      background: var(--color-bg-tertiary);
      color: var(--color-text);
    }

    .tab-btn.active {
      background: var(--color-primary);
      color: var(--color-text);
    }

    /* === Body: 500px, 4 columns === */
    .plugin-body {
      height: var(--body-height);
      padding: var(--body-padding);
      display: flex;
      gap: var(--column-gap);
      flex-shrink: 0;
      overflow: visible;
    }

    /* === Tab Content Panels === */
    .tab-panel {
      display: none;
      width: 100%;
      gap: var(--column-gap);
    }

    .tab-panel.active {
      display: flex;
    }

    /* === Column Base - Neo-brutalist === */
    .column {
      height: var(--column-height);
      background: var(--color-bg);
      border: var(--border-width) solid var(--color-border-column);
      border-radius: var(--border-radius);
      display: flex;
      flex-direction: column;
      overflow: visible;
    }

    .column:nth-child(1) { width: var(--col1-width); }
    .column:nth-child(2) { width: var(--col2-width); }
    .column:nth-child(3) { width: var(--col3-width); }
    .column:nth-child(4) { width: var(--col4-width); }

    .column-header {
      padding: 12px var(--space-lg);
      border-bottom: var(--border-width) solid var(--color-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
      min-height: 54px;
      box-sizing: border-box;
    }

    /* Align Selection and Status Check column headers with other columns */
    #selection-column .column-header,
    #status-check-column .column-header {
      min-height: 56.5px;
      height: 56.5px;
    }

    /* Align Import Input and Status Check column headers with other columns */
    #import-input-column .column-header,
    #import-status-column .column-header {
      min-height: 56.5px;
      height: 56.5px;
    }

    .column-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--color-text);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Column tabs for Order/Tree switching */
    .column-tabs {
      display: flex;
      gap: 4px;
      background: #FFD93D;
      padding: 3px;
      border-radius: var(--border-radius);
      border: 1px solid var(--color-border);
    }

    .column-tab {
      padding: 4px 10px;
      font-size: 10px;
      font-weight: 600;
      border: none;
      background: transparent;
      cursor: pointer;
      border-radius: 3px;
      transition: all 0.15s ease;
      color: #333;
    }

    .column-tab.active {
      background: var(--color-bg);
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
      color: #333;
    }

    .column-tab:hover:not(.active) {
      background: rgba(255,255,255,0.5);
    }

    .preview-tab-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .preview-tab-panel:not(.active) {
      display: none !important;
    }

    #export-preview-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      padding: var(--space-md);
    }

    /* Import tree panel section - same padding as export */
    #import-preview-tree-section {
      padding: var(--space-md);
    }

    .column-actions {
      display: flex;
      gap: var(--space-xs);
    }

    .column-body {
      flex: 1;
      overflow-y: auto;
      padding: var(--space-md);
      display: flex;
      flex-direction: column;
    }

    /* Two-faced column (for Import Column 1) */
    .column-face {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }

    /* Column with scroll fade indicators */
    .column-with-scroll-fade {
      position: relative;
    }

    .column-scroll-fade-top,
    .column-scroll-fade-bottom {
      position: absolute;
      left: 0;
      right: 0;
      height: 24px;
      pointer-events: none;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .column-scroll-fade-top {
      top: 54px; /* Below column header */
      background: linear-gradient(to bottom, rgba(0,0,0,0.27) 0%, rgba(0,0,0,0) 100%);
    }

    .column-scroll-fade-bottom {
      bottom: 0;
      background: linear-gradient(to top, rgba(0,0,0,0.27) 0%, rgba(0,0,0,0) 100%);
    }
    
    /* Column body wrapper for positioning fade above footer */
    .column-body-with-fade {
      position: relative;
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
    }
    
    .column-body-with-fade .column-scroll-fade-bottom {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
    }

    .column-scroll-fade-top.visible,
    .column-scroll-fade-bottom.visible {
      opacity: 1;
    }

    /* Custom scrollbar for Status Check column */
    #status-check-column-body::-webkit-scrollbar {
      width: 10px;
    }

    #status-check-column-body::-webkit-scrollbar-track {
      background: #E8E8E8;
      border: 2px solid #000000;
      border-right: 2px solid #FFFFFF;
      border-radius: 6px 0 0 6px;
      margin: 2px 0 2px 2px;
    }

    #status-check-column-body::-webkit-scrollbar-thumb {
      background: #888888;
      border-radius: 6px 0 0 6px;
      border: 2px solid #000000;
      border-right: none;
    }

    #status-check-column-body::-webkit-scrollbar-thumb:hover {
      background: #666666;
    }

    /* Custom scrollbar for Selection column */
    #selection-column-body::-webkit-scrollbar {
      width: 10px;
    }

    #selection-column-body::-webkit-scrollbar-track {
      background: #E8E8E8;
      border: 2px solid #000000;
      border-right: 2px solid #FFFFFF;
      border-radius: 6px 0 0 6px;
      margin: 2px 0 2px 2px;
    }

    #selection-column-body::-webkit-scrollbar-thumb {
      background: #888888;
      border-radius: 6px 0 0 6px;
      border: 2px solid #000000;
      border-right: none;
    }

    #selection-column-body::-webkit-scrollbar-thumb:hover {
      background: #666666;
    }

    /* Custom scrollbar for Import Input column */
    #import-input-column-body::-webkit-scrollbar {
      width: 10px;
    }

    #import-input-column-body::-webkit-scrollbar-track {
      background: #E8E8E8;
      border: 2px solid #000000;
      border-right: 2px solid #FFFFFF;
      border-radius: 6px 0 0 6px;
      margin: 2px 0 2px 2px;
    }

    #import-input-column-body::-webkit-scrollbar-thumb {
      background: #888888;
      border-radius: 6px 0 0 6px;
      border: 2px solid #000000;
      border-right: none;
    }

    #import-input-column-body::-webkit-scrollbar-thumb:hover {
      background: #666666;
    }

    /* Custom scrollbar for Import Status column */
    #import-status-column-body::-webkit-scrollbar {
      width: 10px;
    }

    #import-status-column-body::-webkit-scrollbar-track {
      background: #E8E8E8;
      border: 2px solid #000000;
      border-right: 2px solid #FFFFFF;
      border-radius: 6px 0 0 6px;
      margin: 2px 0 2px 2px;
    }

    #import-status-column-body::-webkit-scrollbar-thumb {
      background: #888888;
      border-radius: 6px 0 0 6px;
      border: 2px solid #000000;
      border-right: none;
    }

    #import-status-column-body::-webkit-scrollbar-thumb:hover {
      background: #666666;
    }

    .column-footer {
      padding: var(--space-md) var(--space-lg);
      border-top: var(--border-width) solid var(--color-border);
      flex-shrink: 0;
      background: #FFD93D;
    }

    /* === Footer: 72px === */
    .plugin-footer {
      height: var(--footer-height);
      border-top: var(--border-width) solid var(--color-border-footer);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 var(--body-padding);
      background: var(--color-bg);
      flex-shrink: 0;
    }

    .footer-brand {
      font-size: 11px;
      color: var(--color-text-secondary);
    }

    .footer-brand span {
      font-weight: 600;
      color: var(--color-text);
    }

    .footer-actions {
      display: flex;
      gap: var(--space-sm);
    }

    .footer-btn {
      padding: 8px 16px;
      font-size: 11px;
      font-weight: 600;
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: all 0.1s ease;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: var(--space-xs);
      border: var(--border-width) solid var(--color-border);
      box-shadow: none;
    }

    .footer-btn:hover {
      box-shadow: var(--shadow);
      transform: translate(-2px, -2px);
    }

    .footer-btn:active {
      box-shadow: none;
      transform: translate(0, 0);
    }

    .footer-btn-tip {
      background: #FFDD00;
      padding: 8px 12px !important;
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      display: inline-flex !important;
      align-items: center;
      font-weight: 600;
      font-size: 12px;
      color: #000;
    }

    .footer-btn-tip:hover {
      box-shadow: var(--shadow);
      transform: translate(-2px, -2px);
    }

    .footer-btn-tip:active {
      box-shadow: none;
      transform: translate(0, 0);
    }

    .footer-btn-shop {
      background: var(--color-bg);
      color: var(--color-text);
      border-color: #FF90E8;
    }

    /* ==========================================================================
       COMPONENT STYLES - NEO-BRUTALIST
       ========================================================================== */

    /* === Buttons - Neo-brutalist with shadow on hover only === */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 10px 16px;
      font-size: 12px;
      font-weight: 600;
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: all 0.1s ease;
      background: var(--color-bg);
      color: var(--color-text);
      box-shadow: none;
    }

    .btn:hover {
      box-shadow: var(--shadow);
      transform: translate(-2px, -2px);
    }

    .btn:active {
      box-shadow: none;
      transform: translate(0, 0);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-primary {
      background: var(--color-primary);
    }

    .btn-primary:hover {
      background: var(--color-primary-hover);
    }

    .btn-secondary {
      background: var(--color-bg-secondary);
    }

    .btn-success {
      background: var(--color-success);
      color: white;
    }

    .btn-danger {
      background: #FF4D4F;
      color: white;
      border-color: #000000;
    }

    .btn-danger:hover {
      background: #FF2020;
    }

    .btn-small {
      padding: 6px 10px;
      font-size: 10px;
    }

    .btn-small:hover {
      box-shadow: 2px 2px 0px 0px #000000;
      transform: translate(-1px, -1px);
    }

    /* Flash animation for clear button after import */
    @keyframes flash-attention {
      0%, 100% {
        border-color: var(--color-border);
        box-shadow: none;
        transform: scale(1);
      }
      25%, 75% {
        border-color: #FF4D4F;
        box-shadow: 0 0 8px rgba(255, 77, 79, 0.5);
        transform: scale(1.05);
      }
      50% {
        border-color: #FF2020;
        box-shadow: 0 0 12px rgba(255, 32, 32, 0.6);
        transform: scale(1.08);
      }
    }

    .btn-flash-attention {
      animation: flash-attention 0.8s ease-in-out 3;
    }

    .btn-flash-attention:hover {
      animation: none;
      border-color: #FF4D4F;
      box-shadow: 3px 3px 0px 0px #FF4D4F;
      transform: translate(-2px, -2px) scale(1.05);
    }

    .btn-small:active {
      box-shadow: none;
      transform: translate(0, 0);
    }

    .btn-icon {
      padding: 0;
      width: 28px;
      height: 28px;
      min-width: 28px;
      font-size: 16px;
    }

    .btn-full {
      width: 100%;
    }

    /* Export/Import Special Buttons */
    .btn-export {
      background: #FF90E8;
      color: #000000;
      font-weight: 700;
    }

    .btn-export:hover {
      background: #FF70D8;
    }

    .btn-import {
      background: #FF90E8;
      color: #000000;
      font-weight: 700;
    }

    .btn-import:hover {
      background: #FF70D8;
    }

    /* Section Cards - Yellow/Red themed containers */
    .section-card {
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      padding: 12px;
    }

    .section-card-yellow {
      background: #FFD93D;
    }

    .section-card-red {
      background: #FFF0F0;
      border-color: var(--color-error);
    }

    .section-card-header {
      font-size: 11px;
      font-weight: 700;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .section-card-header-red {
      color: var(--color-error);
    }

    .section-card-header-yellow {
      color: #000000;
    }

    .section-card-actions {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }

    .section-card-actions .btn {
      flex: 1;
    }

    /* Collections list inside section cards */
    .section-card .collections-list {
      background: var(--color-bg);
      min-height: 200px;
      max-height: 280px;
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      position: relative;
    }

    /* Custom scrollbar for collections list */
    .section-card .collections-list::-webkit-scrollbar {
      width: 10px;
    }

    .section-card .collections-list::-webkit-scrollbar-track {
      background: #E8E8E8;
      border: 2px solid #000000;
      border-right: 2px solid #FFFFFF;
      border-radius: 6px 0 0 6px;
      margin: 2px 0 2px 2px;
    }

    .section-card .collections-list::-webkit-scrollbar-thumb {
      background: #888888;
      border-radius: 6px 0 0 6px;
      border: 2px solid #000000;
      border-right: none;
    }

    .section-card .collections-list::-webkit-scrollbar-thumb:hover {
      background: #666666;
    }

    /* Scroll fade container for top/bottom shadow gradients */
    .scroll-fade-container {
      position: relative;
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .scroll-fade-container::before,
    .scroll-fade-container::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      height: 20px;
      pointer-events: none;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .scroll-fade-container::before {
      top: 0;
      background: linear-gradient(to bottom, rgba(0,0,0,0.27) 0%, rgba(0,0,0,0) 100%);
      border-radius: var(--border-radius) var(--border-radius) 0 0;
    }

    .scroll-fade-container::after {
      bottom: 0;
      background: linear-gradient(to top, rgba(0,0,0,0.27) 0%, rgba(0,0,0,0) 100%);
      border-radius: 0 0 var(--border-radius) var(--border-radius);
    }

    .scroll-fade-container.scroll-top::before {
      opacity: 1;
    }

    .scroll-fade-container.scroll-bottom::after {
      opacity: 1;
    }

    /* Styles options vertical layout with white background */
    .styles-options-vertical {
      display: flex;
      flex-direction: column;
      gap: 2px;
      background: var(--color-bg);
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      padding: 8px;
    }

    /* Style count badge */
    .style-count {
      margin-left: auto;
      font-size: 10px;
      color: var(--color-text-secondary);
    }

    /* Stats Section with title */
    .stats-section {
      background: #FFD93D;
      border: 2px solid #000000;
      border-radius: var(--border-radius);
      padding: 10px;
    }

    /* Consistent spacing between stats sections - matches container padding */
    .stats-section + .stats-section {
      margin-top: 12px;
    }

    .stats-section-title {
      font-size: 11px;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--color-text);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    /* Fixed Total Header (second header in Preview column) */
    .stats-total-header {
      background: #FFD93D;
      padding: 6px var(--space-md);
      border-bottom: 2px solid #000000;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      flex-shrink: 0;
    }

    .stats-total-header.hidden {
      display: none;
    }

    .stats-total-header .stat-total-value {
      font-size: 18px;
      font-weight: 700;
      color: #333;
    }

    .stats-total-header .stat-total-label {
      font-size: 10px;
      font-weight: 600;
      color: #333;
    }

    /* Preview stats scroll container */
    .preview-stats-scroll-container {
      position: relative;
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }

    .preview-stats-scroll-content {
      flex: 1;
      overflow-y: auto;
      padding: var(--space-md);
    }

    /* Custom scrollbar for Preview Order panel */
    .preview-stats-scroll-content::-webkit-scrollbar {
      width: 10px;
    }

    .preview-stats-scroll-content::-webkit-scrollbar-track {
      background: #E8E8E8;
      border: 2px solid #000000;
      border-right: 2px solid #FFFFFF;
      border-radius: 6px 0 0 6px;
      margin: 2px 0 2px 2px;
    }

    .preview-stats-scroll-content::-webkit-scrollbar-thumb {
      background: #888888;
      border-radius: 6px 0 0 6px;
      border: 2px solid #000000;
      border-right: none;
    }

    .preview-stats-scroll-content::-webkit-scrollbar-thumb:hover {
      background: #666666;
    }

    /* Scroll fade shadows for preview stats */
    .preview-scroll-fade-top,
    .preview-scroll-fade-bottom {
      position: absolute;
      left: 0;
      right: 0;
      height: 24px;
      pointer-events: none;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .preview-scroll-fade-top {
      top: 0;
      background: linear-gradient(to bottom, rgba(0,0,0,0.27) 0%, rgba(0,0,0,0) 100%);
    }

    .preview-scroll-fade-bottom {
      bottom: 0;
      background: linear-gradient(to top, rgba(0,0,0,0.27) 0%, rgba(0,0,0,0) 100%);
    }

    .preview-scroll-fade-top.visible,
    .preview-scroll-fade-bottom.visible {
      opacity: 1;
    }

    .stats-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      margin-bottom: 6px;
    }

    .stats-row:last-child {
      margin-bottom: 0;
    }

    .stats-row.stats-row-3col {
      grid-template-columns: 1fr 1fr 1fr;
    }

    .stats-row .stat-card {
      background: #ffffff;
      border-radius: var(--border-radius);
      padding: 6px 8px;
      text-align: center;
    }

    .stats-row .stat-card.stat-total {
      background: #FFF1F0;
      border: 2px solid var(--color-error);
    }

    .stats-row .stat-value {
      font-size: 14px;
      font-weight: 700;
      display: block;
      line-height: 1.2;
    }

    .stats-row .stat-label {
      font-size: 9px;
      font-weight: 600;
      color: var(--color-text-secondary);
      text-transform: uppercase;
      line-height: 1.2;
    }

    .stats-row .stat-card.stat-total .stat-label {
      color: var(--color-text);
    }

    /* Stats Grid - 3 columns with total spanning full width */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    .stats-grid .stat-card {
      background: var(--color-bg-secondary);
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius);
      padding: 6px 4px;
      text-align: center;
    }

    .stats-grid .stat-card.stat-total {
      grid-column: 1 / -1;
      background: var(--color-primary);
    }

    .stats-grid .stat-value {
      font-size: 14px;
      font-weight: 700;
      display: block;
      line-height: 1.2;
    }

    .stats-grid .stat-label {
      font-size: 8px;
      color: var(--color-text-secondary);
      text-transform: uppercase;
      line-height: 1.2;
    }

    .stats-grid .stat-card.stat-total .stat-label {
      color: var(--color-text);
    }

    /* Alert Banners for Status Check */
    .alert-banner {
      padding: 10px 12px;
      border-radius: var(--border-radius);
      border: 2px solid;
    }

    .alert-banner.hidden {
      display: none;
    }

    .alert-banner.alert-warning {
      background: #FFF7E6;
      border-color: var(--color-warning);
    }

    .alert-banner.alert-error {
      background: #FFF1F0;
      border-color: var(--color-error);
    }

    .alert-banner.alert-info {
      background: #E8F5E9;
      border-color: #4CAF50;
    }

    .alert-header {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 6px;
    }

    .alert-icon {
      font-size: 14px;
    }

    .alert-title {
      font-weight: 600;
      font-size: 11px;
    }

    .alert-desc {
      font-size: 10px;
      color: #666;
      margin-bottom: 6px;
      line-height: 1.4;
    }

    .alert-list {
      font-size: 10px;
      font-family: var(--font-mono);
      background: rgba(0,0,0,0.05);
      padding: 6px 8px;
      border-radius: 3px;
      margin-bottom: 6px;
    }

    .alert-note {
      font-size: 9px;
      color: #999;
      line-height: 1.4;
      margin: 0;
    }
    
    .alert-item {
      display: inline-block;
      background: #fff;
      padding: 2px 6px;
      margin: 2px;
      border-radius: 2px;
      border: 1px solid #ddd;
      font-size: 10px;
      font-family: var(--font-mono);
    }
    
    .alert-info .alert-item {
      border-color: #C8E6C9;
    }

    /* JSON Preview Area */
    .json-preview-area {
      background: #1a1a1a;
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      height: 100%;
      overflow-y: auto;
      font-family: var(--font-mono);
      font-size: 10px;
      color: #A5D6A7;
      padding: 12px;
    }

    .json-preview-area .empty-state {
      color: #666666;
    }

    /* === Section === */
    .section {
      margin-bottom: var(--space-lg);
    }

    .section-title {
      font-size: 11px;
      font-weight: 700;
      color: var(--color-text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: var(--space-sm);
    }

    /* Form Elements - Neo-brutalist */
    .form-group {
      margin-bottom: 12px;
    }

    .form-label {
      display: block;
      font-size: 11px;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .form-input, .form-select, .form-textarea {
      width: 100%;
      padding: 8px 10px;
      font-size: 12px;
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      background: var(--color-bg);
      font-family: inherit;
    }

    .form-textarea {
      min-height: 120px;
      resize: vertical;
      font-family: var(--font-mono);
      font-size: 10px;
      contain: content;
      -webkit-overflow-scrolling: touch;
    }

    .form-checkbox {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      padding: 6px 0;
    }

    .form-checkbox input {
      width: 16px;
      height: 16px;
      cursor: pointer;
      flex-shrink: 0;
    }

    .form-checkbox span:first-of-type {
      flex: 1;
    }

    /* Footer option for checkboxes above buttons */
    .footer-option {
      margin-bottom: 12px;
      padding: 6px 8px;
      background: #ffffff;
      border-radius: var(--border-radius);
    }

    .footer-option.hidden {
      display: none;
    }

    .form-checkbox-small {
      font-size: 10px;
      padding: 2px 0;
    }

    .form-checkbox-small input {
      width: 14px;
      height: 14px;
    }

    /* Collections List - Optimized for large datasets */
    .collections-list {
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      max-height: 280px;
      overflow-y: auto;
      /* Performance optimizations for smooth scrolling */
      will-change: scroll-position;
      contain: strict;
      overflow-anchor: none;
      -webkit-overflow-scrolling: touch;
      scroll-behavior: auto;
    }

    /* Lazy render off-screen collection items */
    .collection-item {
      content-visibility: auto;
      contain-intrinsic-size: auto 60px;
    }

    .collection-item {
      display: flex;
      align-items: flex-start;
      padding: 10px 12px;
      border-bottom: 1px solid var(--color-bg-tertiary);
      gap: 10px;
      /* GPU acceleration for smooth scrolling */
      transform: translateZ(0);
      backface-visibility: hidden;
    }

    .collection-item:last-child {
      border-bottom: none;
    }

    .collection-item:hover {
      background: var(--color-bg-secondary);
    }

    .collection-item.selected {
      background: rgba(255, 144, 232, 0.2);
    }

    .collection-checkbox {
      flex-shrink: 0;
      margin-top: 2px;
      width: 16px;
      height: 16px;
      cursor: pointer;
      position: relative;
      z-index: 20;
    }

    .collection-info {
      flex: 1;
      min-width: 0;
    }

    .collection-name {
      font-weight: 600;
      font-size: 12px;
    }

    .collection-meta {
      font-size: 10px;
      color: var(--color-text-secondary);
      margin-top: 2px;
    }

    .collection-types {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      margin-top: 4px;
    }

    .type-badge {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 2px;
      font-weight: 600;
      border: 1px solid;
    }

    .type-color { background: #EDE7F6; color: #7B1FA2; border-color: #7B1FA2; }
    .type-float { background: #E3F2FD; color: #1565C0; border-color: #1565C0; }
    .type-boolean { background: #FFF3E0; color: #E65100; border-color: #E65100; }
    .type-string { background: #E8F5E9; color: #2E7D32; border-color: #2E7D32; }

    /* Log Area - Performance optimized */
    .log-area {
      background: #1a1a1a;
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      padding: 10px;
      flex: 1;
      min-height: 0;
      overflow-y: auto;
      overflow-x: hidden;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 10px;
      color: #e0e0e0;
      word-wrap: break-word;
      word-break: break-word;
      /* Performance */
      will-change: scroll-position;
      contain: content;
      -webkit-overflow-scrolling: touch;
    }

    .log-entry {
      padding: 2px 0;
      border-bottom: 1px solid #333;
    }

    .log-entry:last-child {
      border-bottom: none;
    }

    .log-time {
      color: #666;
      margin-right: 6px;
    }

    .log-success { color: #52C41A; }
    .log-error { color: #FF4D4F; }
    .log-warning { color: #FAAD14; }

    /* Stats container (used in both export and import panels) */
    .stats {
      display: flex;
      flex-direction: column;
    }

    /* Note: Main .stats-section styles are defined earlier in the file */

    .stat-value {
      font-size: 14px;
      font-weight: 700;
    }

    .stat-label {
      font-size: 9px;
      color: var(--color-text-secondary);
    }

    /* File Input / Drop Zone */
    .drop-zone {
      border: 2px dashed var(--color-border);
      border-radius: var(--border-radius);
      padding: 20px;
      text-align: center;
      color: var(--color-text-secondary);
      margin-bottom: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .drop-zone:hover, .drop-zone.dragover {
      border-color: var(--color-primary);
      background: rgba(255, 144, 232, 0.1);
    }

    .drop-zone.file-loaded {
      border-color: var(--color-success);
      background: rgba(82, 196, 26, 0.05);
    }

    .loaded-file-name {
      margin-top: 8px;
      padding: 4px 10px;
      background: var(--color-success);
      color: white;
      border-radius: 2px;
      font-size: 10px;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      border: 2px solid #000000;
    }

    .loaded-file-name.hidden {
      display: none;
    }

    .drop-zone-icon {
      font-size: 24px;
      margin-bottom: 8px;
    }

    /* Preview Section */
    .preview-section {
      background: var(--color-bg-secondary);
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      padding: 12px;
      margin-bottom: 12px;
    }

    .preview-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .preview-title {
      font-size: 12px;
      font-weight: 700;
    }

    .preview-actions {
      display: flex;
      gap: 4px;
    }

    .preview-btn {
      padding: 4px 8px;
      font-size: 10px;
      border: 1px solid var(--color-border);
      border-radius: 3px;
      background: var(--color-bg);
      cursor: pointer;
    }

    .preview-btn:hover {
      background: var(--color-bg-tertiary);
    }

    /* Structure Tree - Optimized for large structures */
    .structure-tree {
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 10px;
      background: #1a1a1a;
      color: #e0e0e0;
      padding: 10px;
      border-radius: var(--border-radius);
      flex: 1;
      overflow-y: auto;
      /* Performance */
      will-change: scroll-position;
      contain: content;
      -webkit-overflow-scrolling: touch;
    }

    /* Custom scrollbar for structure tree */
    .structure-tree::-webkit-scrollbar {
      width: 10px;
    }

    .structure-tree::-webkit-scrollbar-track {
      background: #444444;
      border: 2px solid #1a1a1a;
      border-radius: 6px;
      margin: 2px;
    }

    .structure-tree::-webkit-scrollbar-thumb {
      background: #888888;
      border-radius: 6px;
      border: 2px solid #1a1a1a;
    }

    .structure-tree::-webkit-scrollbar-thumb:hover {
      background: #AAAAAA;
    }

    .tree-collection {
      margin-bottom: 8px;
      content-visibility: auto;
      contain-intrinsic-size: auto 40px;
    }

    .tree-collection-name {
      color: #FF90E8;
      font-weight: 600;
    }

    .tree-mode {
      margin-left: 12px;
      color: #64B5F6;
    }

    .tree-var {
      margin-left: 24px;
      color: #A5D6A7;
    }

    .tree-type {
      color: #FFB74D;
      font-size: 9px;
    }

    /* Tree Node Styling */
    .tree-node {
      margin-bottom: 8px;
    }

    .tree-node-header {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      margin-bottom: 4px;
    }

    .tree-node .tree-icon {
      font-size: 14px;
    }

    .tree-node .tree-name {
      flex: 1;
      color: #FF90E8;
      font-weight: 600;
    }

    .tree-node .tree-badge {
      background: rgba(255, 144, 232, 0.2);
      color: #FF90E8;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 9px;
    }

    .tree-node .tree-count {
      color: #64B5F6;
      font-size: 9px;
    }

    .tree-children {
      margin-left: 16px;
      padding-left: 8px;
      border-left: 1px solid rgba(255, 255, 255, 0.1);
    }

    .tree-children .tree-mode {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 2px 4px;
      margin-bottom: 2px;
    }

    .tree-children .tree-mode .tree-name {
      color: #64B5F6;
      font-weight: normal;
    }

    /* Grid */
    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    /* Help text */
    .help-text {
      font-size: 10px;
      color: var(--color-text-secondary);
      margin-top: 4px;
    }

    /* Empty State */
    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--color-text-tertiary);
      text-align: center;
      padding: var(--space-lg);
    }

    .empty-state .empty-icon {
      font-size: 32px;
      margin-bottom: var(--space-sm);
      opacity: 0.5;
    }

    /* Hidden utility */
    .hidden {
      display: none !important;
    }

    /* Skeleton Loading Styles */
    .skeleton-container {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 12px;
    }
    .skeleton-item {
      background: linear-gradient(90deg, var(--color-bg-secondary) 25%, var(--color-bg-tertiary) 50%, var(--color-bg-secondary) 75%);
      background-size: 200% 100%;
      animation: skeleton-shimmer 1.5s ease-in-out infinite;
      border-radius: var(--border-radius);
    }
    .skeleton-banner {
      height: 56px;
      margin-bottom: 4px;
    }
    .skeleton-accordion {
      height: 48px;
    }
    .skeleton-section {
      height: 72px;
    }
    .skeleton-stat-row {
      display: flex;
      gap: 8px;
    }
    .skeleton-stat {
      flex: 1;
      height: 52px;
    }
    .skeleton-tree-item {
      height: 28px;
      margin-left: 12px;
    }
    .skeleton-tree-item:first-child {
      margin-left: 0;
      height: 32px;
    }
    @keyframes skeleton-shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    /* Styles options layout */
    .styles-options {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
    }

    /* Log styles */
    .log-area {
      font-family: var(--font-mono);
      font-size: 10px;
      background: #1a1a1a;
      color: #e0e0e0;
      border-radius: var(--border-radius);
      padding: var(--space-sm);
      height: 100%;
      overflow-y: auto;
    }

    /* JSON Preview Section */
    .json-preview-section {
      background: #FFD93D;
      border-radius: var(--border-radius);
      border: 2px solid #000000;
      display: flex;
      flex-direction: column;
      max-height: 200px;
      flex-shrink: 0;
      overflow: hidden;
    }

    .json-preview-section.hidden {
      display: none;
    }

    .json-preview-header {
      display: flex;
      align-items: center;
      padding: 8px 10px;
    }

    .json-preview-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--color-text);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .json-preview-footer {
      display: flex;
      gap: 6px;
      padding: 8px 10px;
    }

    .json-preview-footer .btn {
      flex: 1;
      justify-content: center;
    }

    .json-preview-body {
      padding: 0 var(--space-sm);
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }

    .json-preview-content {
      font-family: var(--font-mono);
      font-size: 9px;
      color: #1a1a1a;
      background: #f5f5f5;
      padding: var(--space-sm);
      margin: 0;
      overflow-y: auto;
      overflow-x: hidden;
      white-space: pre-wrap;
      word-break: break-all;
      flex: 1;
      min-height: 0;
      border-radius: var(--border-radius);
      border: 2px solid #000000;
      /* Hide scrollbar but keep scrollable */
      scrollbar-width: none;
      -ms-overflow-style: none;
    }

    .json-preview-content::-webkit-scrollbar {
      display: none;
    }

    .log-entry {
      padding: 3px 0;
      border-bottom: 1px solid #333;
      display: flex;
      gap: var(--space-sm);
    }

    .log-entry:last-child {
      border-bottom: none;
    }

    .log-time {
      color: #666;
      flex-shrink: 0;
    }

    .log-success { color: #52C41A; }
    .log-error { color: #FF4D4F; }
    .log-warning { color: #FAAD14; }
    .log-info { color: #e0e0e0; }

    /* Loaded File Indicator (Import Panel) */
    .loaded-file-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      background: #e8f5e9;
      border: 2px solid #000;
      border-radius: var(--border-radius);
    }
    
    .loaded-file-indicator.hidden {
      display: none;
    }
    
    .loaded-file-indicator .file-icon {
      font-size: 14px;
    }
    
    .loaded-file-indicator .file-name {
      flex: 1;
      font-family: var(--font-mono);
      font-size: 11px;
      color: #1b5e20;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    /* Import Result Stats */
    .import-result-stats {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px;
      background: #f5f5f5;
      border-radius: var(--border-radius);
      border: 2px solid #000;
    }
    
    .import-result-stats .result-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 11px;
    }
    
    .import-result-stats .result-label {
      color: #333;
    }
    
    .import-result-stats .result-value {
      font-family: var(--font-mono);
      font-weight: 600;
    }
    
    .import-result-stats .result-value.success {
      color: #52C41A;
    }
    
    .import-result-stats .result-value.warning {
      color: #FAAD14;
    }
    
    .import-result-stats .result-value.error {
      color: #FF4D4F;
    }
    
    /* Import Undo Section */
    .import-undo-section {
      margin-top: 8px;
      padding: 10px;
      background: rgba(255, 77, 79, 0.08);
      border: 1px dashed rgba(255, 77, 79, 0.3);
      border-radius: 6px;
      text-align: center;
    }
    
    .import-undo-section.hidden {
      display: none;
    }
    
    .undo-import-btn {
      background: linear-gradient(135deg, #FF4D4F, #FF7875);
      border: none;
      color: white;
      font-weight: 600;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      width: 100%;
      transition: all 0.2s ease;
    }
    
    .undo-import-btn:hover {
      background: linear-gradient(135deg, #FF7875, #FF4D4F);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(255, 77, 79, 0.3);
    }
    
    .undo-import-btn:active {
      transform: translateY(0);
    }
    
    .undo-import-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .undo-icon {
      font-size: 14px;
    }
    
    .undo-hint {
      display: block;
      margin-top: 6px;
      font-size: 10px;
      color: var(--color-text-tertiary);
    }
    
    /* Styles Options Vertical Layout */
    .styles-options-vertical {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .styles-options-vertical .form-checkbox {
      width: 100%;
    }
    
    .styles-options-vertical .style-name {
      font-size: 11px;
    }

    /* Loading spinner */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-sm);
      padding: var(--space-xl);
      color: var(--color-text-secondary);
    }

    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid var(--color-border);
      border-top-color: var(--color-primary);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Validation Alerts */
    .validation-section {
      margin-bottom: 12px;
    }

    .validation-alert {
      padding: 10px 12px;
      border-radius: var(--border-radius);
      border: var(--border-width) solid;
      font-size: 11px;
    }
    
    .validation-alert:not(:last-child) {
      margin-bottom: 8px;
    }

    .validation-alert.error {
      background: #FFF2F2;
      border-color: var(--color-error);
      color: #8B0000;
    }

    .validation-alert.warning {
      background: #FFFBEB;
      border-color: var(--color-warning);
      color: #7D5A00;
    }

    .validation-alert.success {
      background: #F0FFF4;
      border-color: var(--color-success);
      color: #006400;
    }

    .validation-alert-title {
      font-weight: 700;
      margin-bottom: 4px;
    }

    .validation-alert ul {
      margin: 0;
      padding-left: 16px;
    }

    .validation-alert li {
      margin: 2px 0;
    }

    /* Plan Selector */
    .plan-selector {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      margin-bottom: 12px;
    }

    .plan-option {
      padding: 8px 6px;
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      text-align: center;
      cursor: pointer;
      font-size: 10px;
      background: var(--color-bg);
      transition: all 0.1s ease;
      box-shadow: none;
    }

    .plan-option:hover {
      background: var(--color-bg-secondary);
      box-shadow: var(--shadow);
      transform: translate(-1px, -1px);
    }

    .plan-option:active {
      box-shadow: none;
      transform: translate(0, 0);
    }

    .plan-option.selected {
      background: var(--color-primary);
      font-weight: 600;
      border-color: #000000;
      box-shadow: none;
    }

    .plan-option .plan-name {
      font-weight: 600;
      display: block;
    }

    .plan-option .plan-modes {
      color: var(--color-text-secondary);
      font-size: 9px;
    }

    .plan-option.selected .plan-modes {
      color: inherit;
    }

    /* Detected Plan Banner */
    .detected-plan-banner {
      background: linear-gradient(135deg, #E8F5E9 0%, #C8E6C9 100%);
      border: var(--border-width) solid #000000;
      border-radius: var(--border-radius);
      padding: 10px 12px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .detected-plan-banner .plan-icon {
      font-size: 20px;
    }

    .detected-plan-banner .plan-info {
      flex: 1;
    }

    .detected-plan-banner .plan-label {
      font-size: 10px;
      color: #2E7D32;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .detected-plan-banner .plan-value {
      font-size: 14px;
      font-weight: 700;
      color: #1B5E20;
    }

    .detected-plan-banner .plan-detail {
      font-size: 10px;
      color: #388E3C;
    }

    /* Source JSON Plan Banner (amber/yellow variant) */
    #source-plan-banner {
      background: linear-gradient(135deg, #FFF8E1 0%, #FFECB3 100%);
    }

    #source-plan-banner .plan-label {
      color: #F57C00;
    }

    #source-plan-banner .plan-value {
      color: #E65100;
    }

    #source-plan-banner .plan-detail {
      color: #FF9800;
    }

    /* Library Status Card */
    .library-status-card {
      border-radius: var(--border-radius);
      padding: 10px 12px;
      font-size: 11px;
    }

    .library-status-card.library-available {
      background: linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 100%);
      border: var(--border-width) solid #2196F3;
    }

    .library-status-card.library-missing {
      background: linear-gradient(135deg, #FFF3E0 0%, #FFE0B2 100%);
      border: var(--border-width) solid #FF9800;
    }

    .library-status-card.library-partial {
      background: linear-gradient(135deg, #FFFDE7 0%, #FFF9C4 100%);
      border: var(--border-width) solid #FFC107;
    }

    .library-status-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .library-status-icon {
      font-size: 18px;
    }

    .library-status-title {
      font-weight: 700;
      font-size: 12px;
    }

    .library-status-card.library-available .library-status-title {
      color: #1565C0;
    }

    .library-status-card.library-missing .library-status-title {
      color: #E65100;
    }

    .library-status-card.library-partial .library-status-title {
      color: #F57F17;
    }

    .library-status-message {
      margin-bottom: 8px;
      line-height: 1.4;
    }

    .library-collection-list {
      background: rgba(255, 255, 255, 0.6);
      border-radius: 4px;
      padding: 8px;
      margin-top: 8px;
    }

    .library-collection-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 0;
      font-size: 10px;
    }

    .library-collection-item .status-icon {
      font-size: 12px;
    }

    .library-collection-item.available {
      color: #1B5E20;
    }

    .library-collection-item.missing {
      color: #BF360C;
    }

    .library-import-options {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(0, 0, 0, 0.1);
    }

    .library-import-options label {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      cursor: pointer;
      font-size: 10px;
      margin-bottom: 6px;
    }

    .library-import-options input[type="radio"] {
      margin-top: 2px;
    }

    .library-option-desc {
      color: var(--color-text-secondary);
      font-size: 9px;
      margin-top: 2px;
    }

    /* Font Status Card */
    .font-status-card {
      border-radius: var(--border-radius);
      padding: 10px 12px;
      font-size: 11px;
    }

    .font-status-card.font-available {
      background: linear-gradient(135deg, #E8F5E9 0%, #C8E6C9 100%);
      border: var(--border-width) solid #4CAF50;
    }

    .font-status-card.font-missing {
      background: linear-gradient(135deg, #FCE4EC 0%, #F8BBD0 100%);
      border: var(--border-width) solid #E91E63;
    }

    .font-status-card.font-partial {
      background: linear-gradient(135deg, #FFF3E0 0%, #FFE0B2 100%);
      border: var(--border-width) solid #FF9800;
    }

    .font-status-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .font-status-icon {
      font-size: 18px;
    }

    .font-status-title {
      font-weight: 700;
      font-size: 12px;
    }

    .font-status-card.font-available .font-status-title {
      color: #2E7D32;
    }

    .font-status-card.font-missing .font-status-title {
      color: #AD1457;
    }

    .font-status-card.font-partial .font-status-title {
      color: #E65100;
    }

    .font-status-message {
      margin-bottom: 8px;
      line-height: 1.4;
    }

    .font-list {
      background: rgba(255, 255, 255, 0.6);
      border-radius: 4px;
      padding: 8px;
      margin-top: 8px;
      max-height: 150px;
      overflow-y: auto;
    }

    .font-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 0;
      font-size: 10px;
    }

    .font-item .status-icon {
      font-size: 12px;
    }

    .font-item.available {
      color: #1B5E20;
    }

    .font-item.missing {
      color: #880E4F;
    }

    .font-tip {
      margin-top: 8px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 4px;
      font-size: 10px;
      color: #5D4037;
    }

    /* Mode Selection - Optimized for many modes */
    .mode-selection-section {
      margin-top: 12px;
      background: #FFF8E1;
      border: var(--border-width) solid #FFC107;
      border-radius: var(--border-radius);
      position: relative;
    }

    .mode-selection-header {
      padding: 12px 12px 0 12px;
    }

    .mode-selection-scroll-container {
      position: relative;
      max-height: 250px;
      overflow-y: auto;
      padding: 8px 12px 12px 12px;
      /* Performance */
      will-change: scroll-position;
      -webkit-overflow-scrolling: touch;
    }

    /* Visible scrollbar for mode selection */
    .mode-selection-scroll-container::-webkit-scrollbar {
      width: 6px;
    }
    .mode-selection-scroll-container::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.05);
      border-radius: 3px;
    }
    .mode-selection-scroll-container::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 3px;
    }
    .mode-selection-scroll-container::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 0, 0, 0.3);
    }

    /* Scroll fade indicators for mode selection */
    .mode-selection-fade-top,
    .mode-selection-fade-bottom {
      position: absolute;
      left: 0;
      right: 0;
      height: 20px;
      pointer-events: none;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    .mode-selection-fade-top {
      top: 0;
      background: linear-gradient(to bottom, rgba(255, 248, 225, 0.95) 0%, rgba(255, 248, 225, 0) 100%);
    }
    .mode-selection-fade-bottom {
      bottom: 0;
      background: linear-gradient(to top, rgba(255, 248, 225, 0.95) 0%, rgba(255, 248, 225, 0) 100%);
    }
    .mode-selection-fade-top.visible,
    .mode-selection-fade-bottom.visible {
      opacity: 1;
    }

    .mode-selection-title {
      font-size: 12px;
      font-weight: 700;
      color: #F57F17;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .mode-selection-help {
      font-size: 10px;
      color: #6D4C00;
      margin-bottom: 10px;
    }

    .collection-mode-selector {
      background: var(--color-bg);
      border: 1px solid #FFD54F;
      border-radius: var(--border-radius);
      padding: 10px;
      margin-bottom: 8px;
      /* Lazy render for large mode lists */
      content-visibility: auto;
      contain-intrinsic-size: auto 80px;
    }

    .collection-mode-selector:last-child {
      margin-bottom: 0;
    }

    .collection-mode-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .collection-mode-name {
      font-weight: 600;
      font-size: 11px;
    }

    .collection-mode-count {
      font-size: 10px;
      color: var(--color-text-secondary);
      padding: 2px 6px;
      border-radius: 4px;
    }

    .collection-mode-count.valid {
      color: var(--color-success);
      background: rgba(82, 196, 26, 0.1);
      font-weight: 600;
    }

    .collection-mode-count.exceeded {
      color: var(--color-error);
      background: rgba(255, 77, 79, 0.1);
      font-weight: 600;
    }

    .collection-within-limit {
      border-color: var(--color-success) !important;
    }

    .collection-exceeds-limit {
      border-color: var(--color-warning) !important;
    }

    .mode-checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .mode-checkbox-label {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      background: var(--color-bg-secondary);
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      font-size: 10px;
      cursor: pointer;
      transition: all 0.1s ease;
      box-shadow: none;
    }

    .mode-checkbox-label:hover {
      background: var(--color-bg-tertiary);
      box-shadow: var(--shadow);
      transform: translate(-1px, -1px);
    }

    .mode-checkbox-label:active {
      box-shadow: none;
      transform: translate(0, 0);
    }

    .mode-checkbox-label.selected {
      background: var(--color-primary);
      border-color: #000000;
      box-shadow: none;
    }

    .mode-checkbox-label.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .mode-checkbox-label input {
      display: none;
    }

    /* Hidden */
    .hidden {
      display: none !important;
    }

    /* Styles Options */
    .styles-options {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      padding: 10px;
      background: var(--color-bg-secondary);
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
    }

    /* Empty State */
    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 32px 20px;
      text-align: center;
    }
    .empty-icon {
      font-size: 32px;
      margin-bottom: 12px;
      opacity: 0.6;
    }
    .empty-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--color-text);
      margin-bottom: 4px;
    }
    .empty-desc {
      font-size: 12px;
      color: var(--color-text-secondary);
    }

    /* Loading */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      color: var(--color-text-secondary);
    }

    .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid var(--color-bg-tertiary);
      border-top-color: var(--color-primary);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-right: 8px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Persistent Footer */
    .plugin-footer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--color-bg);
      border-top: var(--border-width) solid var(--color-border);
      padding: 10px 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      z-index: 100;
    }

    .footer-brand {
      font-size: 10px;
      color: var(--color-text-secondary);
    }

    .footer-brand span {
      color: var(--color-text);
      font-weight: 600;
    }

    .footer-actions {
      display: flex;
      gap: 6px;
    }

    .footer-btn {
      padding: 6px 10px;
      font-size: 10px;
      font-weight: 600;
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: all 0.1s ease;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .footer-btn-tip {
      background: #FFDD00;
      padding: 8px 12px !important;
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      display: inline-flex !important;
      align-items: center;
      font-weight: 600;
      font-size: 12px;
      color: #000;
    }

    .footer-btn-shop {
      background: var(--color-bg);
      color: var(--color-text);
    }

    .footer-btn-shop:hover {
      background: var(--color-bg-secondary);
      box-shadow: var(--shadow);
      transform: translate(-1px, -1px);
    }

    /* Tip Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
    }

    .modal-overlay.visible {
      opacity: 1;
      visibility: visible;
    }

    .modal {
      background: var(--color-bg);
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      box-shadow: 6px 6px 0px 0px #000000;
      padding: 20px;
      max-width: 320px;
      width: 90%;
      transform: scale(0.9);
      transition: transform 0.2s ease;
    }

    .modal-overlay.visible .modal {
      transform: scale(1);
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }

    .modal-title {
      font-size: 14px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .modal-close {
      background: #FFD93D;
      border: 2px solid #000000;
      border-radius: var(--border-radius);
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      color: var(--color-text);
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }

    .modal-close:hover {
      background: #FFC107;
      color: var(--color-text);
    }

    .modal-body {
      font-size: 12px;
      color: var(--color-text-secondary);
      line-height: 1.5;
      margin-bottom: 16px;
    }

    .modal-body p {
      margin-bottom: 12px;
    }

    /* Landscape Tip Modal Layout */
    .tip-modal-landscape {
      display: flex;
      gap: 20px;
      align-items: stretch;
    }

    .tip-modal-qr-side {
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
    }

    .tip-modal-qr-side .tip-qr-placeholder {
      width: 150px;
      height: 150px;
      border: 3px solid var(--color-border);
      border-radius: var(--border-radius);
      background: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #000;
      transition: all 0.1s ease;
    }

    .tip-modal-qr-side .tip-qr-placeholder:hover {
      box-shadow: var(--shadow);
      transform: translate(-2px, -2px);
    }

    .tip-modal-qr-side .tip-qr-label {
      font-size: 10px;
      color: var(--color-text-secondary);
      margin-top: auto;
      padding-top: 8px;
      text-align: center;
    }

    .tip-modal-content-side {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .tip-modal-content-side .modal-body {
      margin-bottom: 0;
      flex: 1;
    }

    .tip-modal-content-side .modal-body p {
      margin-bottom: 8px;
    }

    .tip-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .tip-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px 16px;
      font-size: 12px;
      font-weight: 600;
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: all 0.1s ease;
      text-decoration: none;
      color: var(--color-text);
      box-shadow: none;
    }

    .tip-btn:hover {
      box-shadow: var(--shadow);
      transform: translate(-2px, -2px);
    }

    .tip-btn:active {
      box-shadow: none;
      transform: translate(0, 0);
    }

    .tip-btn-bmc {
      background: #FFDD00;
      padding: 12px 20px !important;
      overflow: visible;
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--border-radius);
      display: inline-flex !important;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 14px;
      color: #000;
    }

    .tip-btn-bmc:hover {
      box-shadow: var(--shadow);
      transform: translate(-2px, -2px);
    }

    .tip-btn-bmc:active {
      box-shadow: none;
      transform: translate(0, 0);
    }

    .tip-qr-link {
      text-decoration: none;
    }

    .modal-footer {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--color-bg-tertiary);
      font-size: 10px;
      color: var(--color-text-secondary);
      text-align: center;
    }
  </style>
</head>
<body>
  <!-- ============================================================
       HEADER - 56px centered tab switcher
       ============================================================ -->
  <header class="plugin-header">
    <!-- Spacer to balance header layout -->
    <div class="header-spacer"></div>
    <div class="tab-switcher">
      <button class="tab-btn active" data-tab="export">↗️ Export</button>
      <button class="tab-btn" data-tab="import">↙️ Import</button>
    </div>
    <!-- User Mode Toggle (right side) -->
    <div class="user-mode-toggle" id="user-mode-toggle">
      <input type="radio" id="mode-simple" name="user-mode" value="simple" checked>
      <label for="mode-simple" class="mode-label">Simple</label>
      <input type="radio" id="mode-advanced" name="user-mode" value="advanced">
      <label for="mode-advanced" class="mode-label">Advanced</label>
    </div>
  </header>

  <!-- ============================================================
       BODY - 500px, 4-column layout
       ============================================================ -->
  <main class="plugin-body">
    
    <!-- ========== EXPORT TAB ========== -->
    <div id="export-panel" class="tab-panel active">
      
      <!-- Column 1: Selection -->
      <div class="column column-with-scroll-fade" id="selection-column">
        <div class="column-scroll-fade-top" id="selection-fade-top"></div>
        <div class="column-scroll-fade-bottom" id="selection-fade-bottom"></div>
        <div class="column-header">
          <span class="column-title">🧩 Selection</span>
          <button class="btn btn-small btn-icon" onclick="refreshCollections()" title="Refresh">🔄</button>
        </div>
        <div class="column-body" id="selection-column-body">
          <!-- Variables Collections Section -->
          <div class="section-card section-card-yellow">
            <div class="section-card-header">
              <span>🗂️ Variables Collections</span>
            </div>
            <div class="section-card-actions">
              <button class="btn btn-secondary btn-small" onclick="selectAllExport(true)">✅ Select All</button>
              <button class="btn btn-secondary btn-small" onclick="selectAllExport(false)"><span style="color: #FF4D4F; font-weight: bold;">✕</span> None</button>
            </div>
            <div class="scroll-fade-container" id="export-collections-container">
              <div class="collections-list" id="export-collections">
                <div class="loading">
                  <div class="spinner"></div>
                  <span>Loading collections...</span>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Select Styles Section -->
          <div class="section-card section-card-yellow" style="margin-top: 12px;">
            <div class="section-card-header">
              <span>🎨 Select Styles</span>
            </div>
            <div class="section-card-actions">
              <button class="btn btn-secondary btn-small" onclick="selectAllStyles(true)">✅ Select All</button>
              <button class="btn btn-secondary btn-small" onclick="selectAllStyles(false)"><span style="color: #FF4D4F; font-weight: bold;">✕</span> None</button>
            </div>
            <div class="styles-options-vertical">
              <label class="form-checkbox" id="text-styles-label">
                <input type="checkbox" id="export-text-styles" onclick="event.stopPropagation()" onchange="updateExportPreview()">
                <span class="style-name">✏️ Text Styles</span>
                <span class="style-count" id="text-style-count">(0)</span>
              </label>
              <label class="form-checkbox" id="color-styles-label">
                <input type="checkbox" id="export-color-styles" onclick="event.stopPropagation()" onchange="updateExportPreview()">
                <span class="style-name">🎨 Colour Styles</span>
                <span class="style-count" id="color-style-count">(0)</span>
              </label>
              <label class="form-checkbox" id="effect-styles-label">
                <input type="checkbox" id="export-effect-styles" onclick="event.stopPropagation()" onchange="updateExportPreview()">
                <span class="style-name">✨ Effect Styles</span>
                <span class="style-count" id="effect-style-count">(0)</span>
              </label>
              <label class="form-checkbox" id="grid-styles-label">
                <input type="checkbox" id="export-grid-styles" onclick="event.stopPropagation()" onchange="updateExportPreview()">
                <span class="style-name">📐 Layout Guides</span>
                <span class="style-count" id="grid-style-count">(0)</span>
              </label>
            </div>
            <!-- Include Images Option (Advanced only) -->
            <div class="export-images-option advanced-only-block" id="include-images-label" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--color-border); display: none;">
              <label class="form-checkbox form-checkbox-small">
                <input type="checkbox" id="export-include-images" onclick="event.stopPropagation()" onchange="updateExportPreview()" checked>
                <span style="font-size: 10px;">📸 Include image data (increases file size)</span>
              </label>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Column 2: Status Check (Warnings, Alerts, Dependencies) -->
      <div class="column column-with-scroll-fade" id="status-check-column">
        <div class="column-scroll-fade-top" id="status-check-fade-top"></div>
        <div class="column-scroll-fade-bottom" id="status-check-fade-bottom"></div>
        <div class="column-header">
          <span class="column-title">📋 Status Check</span>
        </div>
        <div class="column-body" id="status-check-column-body">
          <div id="export-status-content" style="display: flex; flex-direction: column; gap: 10px;">
            <!-- Detected File Plan (shows what plan this file uses) -->
            <div id="export-detected-plan-section" class="hidden">
              <div class="detected-plan-banner" id="export-detected-plan-banner">
                <div class="plan-icon">📊</div>
                <div class="plan-info">
                  <div class="plan-label">Source File Plan</div>
                  <div class="plan-value" id="export-detected-plan-value">Starter</div>
                  <div class="plan-detail" id="export-detected-plan-detail">1 mode per collection</div>
                </div>
              </div>
              <p class="plan-hint" id="export-plan-hint" style="font-size: 10px; color: var(--color-text-secondary); margin-top: 6px; padding: 0 4px;">
                💡 Target file needs this plan (or higher) to import all modes.
              </p>
            </div>
            
            <!-- Image Data Warning (shown when images enabled) -->
            <div id="image-warning-banner" class="alert-banner alert-warning hidden">
              <div class="alert-header">
                <span class="alert-icon">📸</span>
                <span class="alert-title">Image Data Included</span>
              </div>
              <p class="alert-desc">Including images will significantly increase file size.</p>
              <p class="alert-note">💡 Only enable if you need to transfer image fills.</p>
            </div>
            
            <!-- Library Dependencies Warning -->
            <div id="library-warning-banner" class="alert-banner alert-warning hidden">
              <div class="alert-header">
                <span class="alert-icon">📚</span>
                <span class="alert-title">External Library Dependencies</span>
              </div>
              <p class="alert-desc">Some variables reference linked library collections:</p>
              <div id="library-deps-list" class="alert-list"></div>
              <p class="alert-note" id="library-warning-note">✅ Library references will be preserved in export.</p>
            </div>
            
            <!-- Plan Compatibility Info -->
            <div id="plan-compatibility-banner" class="alert-banner alert-info hidden">
              <div class="alert-header">
                <span class="alert-icon">📋</span>
                <span class="alert-title">Figma Plan Compatibility</span>
              </div>
              <p class="alert-desc" id="plan-compatibility-desc">Based on mode count per collection:</p>
              <div id="plan-compatibility-list" class="alert-list"></div>
              <p class="alert-note" id="plan-compatibility-note">💡 Max modes detected: <span id="max-modes-detected">0</span> per collection</p>
            </div>
            
            <!-- Asset Source Info -->
            <div id="asset-source-banner" class="alert-banner alert-info hidden">
              <div class="alert-header">
                <span class="alert-icon">📦</span>
                <span class="alert-title">Asset Sources</span>
              </div>
              <div id="asset-source-list" class="alert-list"></div>
            </div>
            
            <!-- Variable Bindings Info -->
            <div id="bindings-info-banner" class="alert-banner alert-info hidden">
              <div class="alert-header">
                <span class="alert-icon">🔗</span>
                <span class="alert-title">Variable Bindings</span>
              </div>
              <div id="bindings-info-list" class="alert-list"></div>
            </div>
            
            <!-- Fonts Used Info -->
            <div id="fonts-used-banner" class="alert-banner alert-info hidden">
              <div class="alert-header">
                <span class="alert-icon">🔤</span>
                <span class="alert-title">Fonts Used</span>
              </div>
              <div id="fonts-used-list" class="alert-list"></div>
            </div>
            
            <!-- Font Requirements Info (shown after export) -->
            <div id="font-requirements-banner" class="alert-banner alert-info hidden">
              <div class="alert-header">
                <span class="alert-icon">🔤</span>
                <span class="alert-title">Font Requirements</span>
              </div>
              <p class="alert-desc">Text styles require these fonts:</p>
              <div id="font-requirements-list" class="alert-list"></div>
              <p class="alert-note">💡 Ensure fonts are installed before importing.</p>
            </div>
          </div>
          <div id="export-empty-status" class="empty-state">
            <span class="empty-icon">⏳</span>
            <span>Loading structure...</span>
          </div>
        </div>
      </div>
      
      <!-- Column 3: Preview (Order/Tree tabs) -->
      <div class="column" id="preview-column">
        <div class="column-header">
          <span class="column-title">📁 Preview</span>
          <div class="column-tabs">
            <button class="column-tab active" data-tab="order" onclick="switchPreviewTab('order')">📋 Order</button>
            <button class="column-tab" data-tab="tree" onclick="switchPreviewTab('tree')">🌲 Tree</button>
          </div>
        </div>
        <!-- Fixed Total Header (second header) -->
        <div class="stats-total-header hidden" id="export-stats-total-header">
          <span class="stat-total-value" id="export-total-value">0</span>
          <span class="stat-total-label">Total Items</span>
        </div>
        <div class="column-body" style="padding: 0;">
          <!-- Order Tab Content -->
          <div id="export-order-panel" class="preview-tab-panel active" style="display: flex; flex-direction: column; height: 100%;">
            <div id="export-stats-section" class="preview-stats-scroll-container">
              <div class="preview-scroll-fade-top" id="preview-stats-fade-top"></div>
              <div class="preview-scroll-fade-bottom" id="preview-stats-fade-bottom"></div>
              <div class="preview-stats-scroll-content" id="preview-stats-scroll-content">
                <div id="export-preview-stats"></div>
              </div>
            </div>
            <div id="export-empty-preview-order" class="empty-state">
              <span class="empty-icon">📊</span>
              <span>Select collections to see stats</span>
            </div>
          </div>
          <!-- Tree Tab Content -->
          <div id="export-tree-panel" class="preview-tab-panel" style="display: none;">
            <div id="export-preview-section" class="hidden">
              <div class="structure-tree" id="export-preview-tree"></div>
            </div>
            <div id="export-empty-preview" class="empty-state">
              <span class="empty-icon">👁️</span>
              <span>Select collections to preview</span>
            </div>
          </div>
        </div>
        <!-- Persistent Footer with Export Button -->
        <div class="column-footer">
          <div id="export-library-option" class="footer-option hidden">
            <label class="form-checkbox form-checkbox-small">
              <input type="checkbox" id="export-preserve-library-refs" checked onchange="updateLibraryWarningNote()">
              <span>Preserve library references (skip local values)</span>
            </label>
          </div>
          <!-- Advanced Options Accordion (Advanced only) -->
          <details class="export-options-accordion advanced-only-block" id="export-advanced-accordion">
            <summary class="export-options-summary">
              <span>⚙️ Export Options</span>
              <span class="accordion-arrow">▼</span>
            </summary>
            <div class="export-options-content">
              <!-- Export Format Option -->
              <div class="footer-option">
                <div class="naming-convention-row">
                  <label class="naming-label">📄 Format:</label>
                  <select id="export-format" class="naming-dropdown" onchange="updateFormatHelp()">
                    <option value="figma">Figma JSON</option>
                    <option value="w3c">W3C Design Tokens</option>
                  </select>
                </div>
              </div>
              <!-- Naming Convention Option -->
              <div class="footer-option">
                <div class="naming-convention-row">
                  <label class="naming-label">🎯 Naming:</label>
                  <select id="export-naming-convention" class="naming-dropdown">
                    <option value="original">Original (keep as-is)</option>
                    <option value="camelCase">camelCase</option>
                    <option value="kebab-case">kebab-case</option>
                    <option value="snake_case">snake_case</option>
                  </select>
                </div>
              </div>
              <!-- Resolve Aliases Option -->
              <div class="footer-option">
                <label class="form-checkbox form-checkbox-small">
                  <input type="checkbox" id="export-resolve-aliases">
                  <span>🔓 Resolve aliases to raw values</span>
                </label>
              </div>
            </div>
          </details>
          <button class="btn btn-export btn-full" onclick="exportVariables()" id="export-btn">
            ↗️ Export Selected
          </button>
        </div>
      </div>
      
      <!-- Column 4: Activity Log -->
      <div class="column">
        <div class="column-header">
          <span class="column-title">📁 Activity Log</span>
          <div class="column-actions">
            <button class="btn btn-small btn-secondary" onclick="copyLog('export')">📋 Copy</button>
            <button class="btn btn-small btn-secondary" onclick="clearLog('export')">🗑️ Clear</button>
          </div>
        </div>
        <div class="column-body" style="display: flex; flex-direction: column; gap: 8px;">
          <div class="log-area" id="log-area-export" style="flex: 1; min-height: 120px;">
            <div class="log-entry">
              <span class="log-time">--:--:--</span>
              <span>Variables Extractor v2.0 ready</span>
            </div>
          </div>
          <!-- JSON Preview Section (appears after export) -->
          <div id="export-json-preview-section" class="json-preview-section hidden">
            <div class="json-preview-header">
              <span class="json-preview-title">📜 Exported JSON</span>
            </div>
            <div class="json-preview-body">
              <pre class="json-preview-content" id="export-json-preview"></pre>
            </div>
            <div class="json-preview-footer">
              <button class="btn btn-small btn-secondary" onclick="copyExport()">📋 Copy</button>
              <button class="btn btn-small btn-secondary" onclick="downloadExport()">💾 Download</button>
            </div>
          </div>
        </div>
      </div>
      
    </div>

    <!-- ========== IMPORT TAB ========== -->
    <div id="import-panel" class="tab-panel">
      
      <!-- Column 1: Input & Select (two-faced column) -->
      <div class="column" id="import-input-column">
        <div class="column-header">
          <span class="column-title">🧩 Input & Select</span>
          <button class="btn btn-small btn-icon" id="import-trash-btn" onclick="resetImportToInputFace()" title="Clear & Start Over" style="background: #fff; display: none;">🗑️</button>
        </div>
        <div class="column-body-wrapper" id="import-input-body-wrapper">
          <div class="column-scroll-fade-top" id="import-input-fade-top"></div>
          <div class="column-scroll-fade-bottom" id="import-input-fade-bottom"></div>
          <div class="column-body" id="import-input-column-body">
            <!-- ===== FACE 1: Input Face ===== -->
            <div id="import-input-face" class="column-face">
              <!-- Paste / Upload Section -->
              <div class="section-card section-card-yellow" id="load-json-section">
                <div class="section-card-header section-card-header-yellow">
                  <span>📥 Load JSON Data</span>
                </div>
                <div class="section-card-actions">
                  <button class="btn btn-secondary btn-small" id="import-clear-btn" onclick="clearImportInput()" style="flex: 1;" disabled>🗑️ Clear</button>
                  <button class="btn btn-secondary btn-small" onclick="document.getElementById('file-input').click()" style="flex: 1;">📁 Upload</button>
                </div>
                <input type="file" id="file-input" accept=".json" style="display: none;">
                <div class="scroll-fade-container" id="import-input-container">
                  <textarea class="form-textarea" id="import-input" placeholder="Paste JSON data (Ctrl/Cmd+V) or upload a JSON file..." oninput="debouncedParseImportPreview()" style="min-height: 140px; margin-top: 8px; resize: none;"></textarea>
                </div>
                <!-- File loaded indicator -->
              <div id="import-file-loaded" class="loaded-file-indicator hidden" style="margin-top: 8px;">
                <span class="file-icon">📄</span>
                <span class="file-name" id="import-file-name"></span>
                <button class="btn btn-small btn-icon" onclick="clearImportInput()" style="padding: 2px 6px; min-width: auto; width: auto;">✕</button>
              </div>
            </div>
          </div>
          
          <!-- ===== FACE 2: Selection Face (like Export's Column 1) ===== -->
          <div id="import-selection-face" class="column-face" style="display: none;">
            <!-- Variables Collections Section -->
            <div class="section-card section-card-yellow">
              <div class="section-card-header">
                <span>🗂️ Variables Collections</span>
              </div>
              <div class="section-card-actions">
                <button class="btn btn-secondary btn-small" onclick="selectAllImport(true)">✅ Select All</button>
                <button class="btn btn-secondary btn-small" onclick="selectAllImport(false)"><span style="color: #FF4D4F; font-weight: bold;">✕</span> None</button>
              </div>
              <div class="scroll-fade-container" id="import-collections-container">
                <div class="collections-list" id="import-collections-list">
                  <!-- Collection items will be populated here -->
                </div>
              </div>
            </div>
            
            <!-- Select Styles Section (if styles exist) -->
            <div class="section-card section-card-yellow" id="import-styles-section" style="margin-top: 12px; display: none;">
              <div class="section-card-header">
                <span>🎨 Select Styles</span>
              </div>
              <div class="section-card-actions">
                <button class="btn btn-secondary btn-small" onclick="selectAllImportStyles(true)">✅ Select All</button>
                <button class="btn btn-secondary btn-small" onclick="selectAllImportStyles(false)"><span style="color: #FF4D4F; font-weight: bold;">✕</span> None</button>
              </div>
              <div class="styles-options-vertical" id="import-styles-options">
                <!-- Style checkboxes will be populated here -->
              </div>
              <!-- Import Images Option (Advanced only - shown when JSON has image data) -->
              <div class="import-images-option advanced-only-block" id="import-images-option" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--color-border); display: none;">
                <label class="form-checkbox form-checkbox-small">
                  <input type="checkbox" id="import-include-images" onclick="event.stopPropagation()" checked>
                  <span style="font-size: 10px;">📸 Include image data from JSON</span>
                </label>
                <div id="import-images-info-text" style="font-size: 9px; color: var(--color-text-secondary); margin-top: 4px; margin-left: 20px; background: white; padding: 2px 6px; border-radius: 4px; display: inline-block;"></div>
              </div>
            </div>
            <!-- Spacer for bottom padding in flex layout -->
            <div style="flex-shrink: 0; height: 12px;"></div>
          </div>
        </div>
        </div>
        <!-- Fixed Footer for Proceed Button (only shows in Input Face) -->
        <div class="column-footer" id="import-proceed-footer">
          <button class="btn btn-primary btn-full" id="import-proceed-btn" onclick="proceedToImportSelection()" disabled>
            ▶️ Proceed to Selection
          </button>
        </div>
        <!-- Fixed Footer for Selection Face (shows Import Behavior accordion - Advanced only) -->
        <div class="column-footer advanced-only-block is-hidden" id="import-selection-footer">
          <details class="import-behavior-accordion" id="import-behavior-accordion">
            <summary class="import-behavior-summary">
              <span>⚙️ Import Behavior</span>
              <span class="accordion-arrow">▼</span>
            </summary>
            <div class="import-behavior-content">
              <div class="import-behavior-toggle">
                <label class="behavior-option">
                  <input type="radio" name="import-behavior" value="smart-merge" checked onchange="updateCustomMergeVisibility()">
                  <div class="behavior-content">
                    <span class="behavior-name">🔄 Smart Merge</span>
                    <span class="behavior-desc">Add new, update existing</span>
                  </div>
                </label>
                <label class="behavior-option">
                  <input type="radio" name="import-behavior" value="clean-import" onchange="updateCustomMergeVisibility()">
                  <div class="behavior-content">
                    <span class="behavior-name">🧹 Clean Import</span>
                    <span class="behavior-desc">Clear first, then import</span>
                  </div>
                </label>
                <label class="behavior-option">
                  <input type="radio" name="import-behavior" value="custom-merge" onchange="updateCustomMergeVisibility()">
                  <div class="behavior-content">
                    <span class="behavior-name">🎯 Custom Merge</span>
                    <span class="behavior-desc">Choose what to clear</span>
                  </div>
                </label>
              </div>
              <!-- Custom Merge Options (hidden by default) -->
              <div class="custom-merge-options" id="custom-merge-options" style="display: none; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--color-border);">
                <div style="font-size: 10px; color: var(--color-text-secondary); margin-bottom: 6px;">Clear before importing:</div>
                <div style="display: flex; gap: 12px;">
                  <label class="form-checkbox form-checkbox-small">
                    <input type="checkbox" id="custom-clear-variables" checked onclick="event.stopPropagation()">
                    <span style="font-size: 10px;">📦 Variables</span>
                  </label>
                  <label class="form-checkbox form-checkbox-small">
                    <input type="checkbox" id="custom-clear-styles" checked onclick="event.stopPropagation()">
                    <span style="font-size: 10px;">🎨 Styles</span>
                  </label>
                </div>
              </div>
            </div>
          </details>
        </div>
      </div>
      
      <!-- Column 2: Check and Validate -->
      <div class="column column-with-scroll-fade" id="import-status-column">
        <div class="column-scroll-fade-top" id="import-status-fade-top"></div>
        <div class="column-header">
          <span class="column-title">📋 Check and Validate</span>
        </div>
        <div class="column-body-with-fade">
          <div class="column-scroll-fade-bottom" id="import-status-fade-bottom"></div>
          <div class="column-body" id="import-status-column-body">
          <!-- Skeleton Loading State -->
          <div id="import-status-skeleton" class="skeleton-container hidden">
            <div class="skeleton-item skeleton-banner"></div>
            <div class="skeleton-item skeleton-accordion"></div>
            <div class="skeleton-item skeleton-section"></div>
          </div>
          
          <div id="import-status-content" style="display: flex; flex-direction: column; gap: 10px;">
            
            <!-- Figma File Plan (accordion with mode info) - Always visible -->
            <details class="plan-accordion" id="figma-plan-accordion">
              <summary class="plan-accordion-summary">
                <div class="plan-accordion-header">
                  <div class="plan-icon">🎯</div>
                  <div class="plan-info">
                    <div class="plan-label">Figma File Plan</div>
                    <div class="plan-value" id="figma-plan-value">Detecting...</div>
                  </div>
                </div>
                <span class="accordion-arrow">▼</span>
              </summary>
              <div class="plan-accordion-content">
                <div class="plan-modes-info">
                  <div class="plan-modes-row" data-plan="starter">
                    <span class="plan-name">🌱 Starter</span>
                    <span class="plan-modes-count">1 mode per collection</span>
                  </div>
                  <div class="plan-modes-row" data-plan="professional">
                    <span class="plan-name">💼 Professional</span>
                    <span class="plan-modes-count">Up to 10 modes</span>
                  </div>
                  <div class="plan-modes-row" data-plan="organization">
                    <span class="plan-name">🏢 Organization</span>
                    <span class="plan-modes-count">Up to 20 modes</span>
                  </div>
                  <div class="plan-modes-row" data-plan="enterprise">
                    <span class="plan-name">🏛️ Enterprise</span>
                    <span class="plan-modes-count">Unlimited modes</span>
                  </div>
                </div>
                <p class="plan-accordion-note">💡 Your Figma file plan determines which modes you can import.</p>
              </div>
            </details>
            
            <!-- ===== PRE-PROCEED SECTIONS (shown before clicking Proceed) ===== -->
            <div id="import-pre-proceed-sections" class="hidden" style="display: flex; flex-direction: column; gap: 10px;">
              <!-- Source JSON Plan (detected from imported JSON - info) -->
              <div id="source-json-plan-section" class="hidden">
                <div class="detected-plan-banner" id="source-plan-banner" style="background: #FFF3CD;">
                  <div class="plan-icon">📄</div>
                  <div class="plan-info">
                    <div class="plan-label">Source JSON Plan</div>
                    <div class="plan-value" id="source-plan-value">Unknown</div>
                    <div class="plan-detail" id="source-plan-detail">Load JSON to detect</div>
                  </div>
                </div>
              </div>
              
              <!-- Plan Compatibility Section (warning/success) -->
              <div id="plan-compatibility-section" class="hidden">
                <div class="compatibility-banner" id="compatibility-banner">
                  <div class="compatibility-status" id="compatibility-status">
                    <span class="compatibility-icon" id="compatibility-icon">✅</span>
                    <span class="compatibility-text" id="compatibility-text">Plans are compatible</span>
                  </div>
                  <p class="compatibility-detail" id="compatibility-detail"></p>
                </div>
              </div>
              
              <!-- Library Status Section (pre-proceed) -->
              <div id="library-status-section-pre" class="hidden">
                <div id="library-status-card-pre" class="library-status-card"></div>
              </div>
              
              <!-- Font Status Section (pre-proceed) -->
              <div id="font-status-section-pre" class="hidden">
                <div id="font-status-card-pre" class="font-status-card"></div>
              </div>
            </div>
            
            <!-- ===== POST-PROCEED SECTIONS (shown after clicking Proceed) ===== -->
            <div id="import-post-proceed-sections" class="hidden" style="display: flex; flex-direction: column; gap: 10px;">
              <!-- Mode Selection Container (moved to top for side-by-side selection) -->
              <div id="mode-selection-container" class="hidden"></div>
              
              <!-- Plan Mismatch Warning -->
              <div id="plan-mismatch-warning" class="alert-banner alert-warning hidden">
                <div class="alert-header">
                  <span class="alert-icon">⚠️</span>
                  <span class="alert-title">Plan Mismatch</span>
                </div>
                <p class="alert-desc" id="plan-mismatch-desc">Source JSON requires a higher plan than your target file.</p>
                <p class="alert-note" id="plan-mismatch-note">💡 Select which modes to import for affected collections above.</p>
              </div>
              
              <!-- External Dependencies Warning (Partial Asset Sources) -->
              <div id="import-external-deps-banner" class="alert-banner alert-warning hidden">
                <div class="alert-header">
                  <span class="alert-icon">🔗</span>
                  <span class="alert-title">External Dependencies</span>
                </div>
                <p class="alert-desc">Some items reference external sources:</p>
                <div id="import-external-deps-list" class="alert-list"></div>
                <p class="alert-note">⚠️ External references may not resolve during import.</p>
              </div>
              
              <!-- Library Status Section (Asset Sources) -->
              <div id="library-status-section" class="hidden">
                <div id="library-status-card" class="library-status-card"></div>
              </div>
              
              <!-- Import Asset Source Info -->
              <div id="import-asset-source-banner" class="alert-banner alert-info hidden">
                <div class="alert-header">
                  <span class="alert-icon">📦</span>
                  <span class="alert-title">Asset Sources</span>
                </div>
                <div id="import-asset-source-list" class="alert-list"></div>
              </div>
              
              <!-- Import Variable Bindings Info -->
              <div id="import-bindings-info-banner" class="alert-banner alert-info hidden">
                <div class="alert-header">
                  <span class="alert-icon">🔗</span>
                  <span class="alert-title">Variable Bindings</span>
                </div>
                <div id="import-bindings-info-list" class="alert-list"></div>
              </div>
              
              <!-- Font Status Section (All Fonts Available) -->
              <div id="font-status-section" class="hidden">
                <div id="font-status-card" class="font-status-card"></div>
              </div>
              
              <!-- Import Compatibility Info -->
              <div id="import-compatibility-banner" class="alert-banner alert-info hidden">
                <div class="alert-header">
                  <span class="alert-icon">📋</span>
                  <span class="alert-title">Import Compatibility</span>
                </div>
                <p class="alert-desc" id="import-compatibility-desc">Checking compatibility...</p>
                <div id="import-compatibility-list" class="alert-list"></div>
              </div>
              
              <!-- Validation Results (Ready to Import) -->
              <div id="validation-results"></div>
            </div>
          </div>
          
          <!-- Empty state -->
          <div id="import-validation-empty" class="empty-state">
            <span class="empty-icon">✅</span>
            <span>Load JSON to validate</span>
          </div>
        </div>
        </div><!-- Close column-body-with-fade wrapper -->
        <!-- Permanent Footer with Import Preview and Import Button -->
        <div class="column-footer" id="import-validate-footer" style="display: none; background: #FF90E8;">
          <!-- Import Preview Accordion -->
          <details class="import-preview-accordion" id="import-diff-accordion" ontoggle="onImportPreviewToggle(this)">
            <summary class="import-preview-summary">
              <span>📊 Review changes</span>
              <span class="accordion-arrow">▼</span>
            </summary>
            <div class="import-preview-content" id="import-diff-section">
              <div class="diff-summary" id="import-diff-summary">
                <div class="diff-row">
                  <span class="diff-label">New</span>
                  <span class="diff-count" id="diff-new-count">0</span>
                </div>
                <div class="diff-row">
                  <span class="diff-label">Modified</span>
                  <span class="diff-count diff-modified" id="diff-modified-count">0</span>
                </div>
                <div class="diff-row">
                  <span class="diff-label">Unchanged</span>
                  <span class="diff-count diff-unchanged" id="diff-unchanged-count">0</span>
                </div>
              </div>
              <div class="diff-breakdown" style="margin-top: 8px; display: flex; flex-direction: column; gap: 4px; font-size: 11px;">
                <div class="diff-breakdown-row" style="display: flex; justify-content: space-between;">
                  <span>🗂️ Collections</span>
                  <span id="diff-collections-counts">(➕0 📝0)</span>
                </div>
                <div class="diff-breakdown-row" style="display: flex; justify-content: space-between;">
                  <span>🎛️ Modes</span>
                  <span id="diff-modes-counts">(➕0 📝0)</span>
                </div>
                <div class="diff-breakdown-row" style="display: flex; justify-content: space-between;">
                  <span>🔢 Variables</span>
                  <span id="diff-variables-counts">(➕0 📝0)</span>
                </div>
                <div class="diff-breakdown-row" style="display: flex; justify-content: space-between;">
                  <span>🎨 Styles</span>
                  <span id="diff-styles-counts">(➕0 📝0)</span>
                </div>
              </div>
            </div>
          </details>
        </div>
      </div>
      
      <!-- Column 3: Preview (Order/Tree tabs - matches Export Preview column) -->
      <div class="column" id="import-preview-column">
        <div class="column-header">
          <span class="column-title">📁 Preview</span>
          <div class="column-tabs">
            <button class="column-tab active" data-tab="import-order" onclick="switchImportPreviewTab('order')">📋 Order</button>
            <button class="column-tab" data-tab="import-tree" onclick="switchImportPreviewTab('tree')">🌲 Tree</button>
          </div>
        </div>
        <!-- Fixed Total Header (second header - matches Export) -->
        <div class="stats-total-header hidden" id="import-stats-total-header">
          <span class="stat-total-value" id="import-total-value">0</span>
          <span class="stat-total-label">Total Items</span>
        </div>
        <div class="column-body" style="padding: 0;">
          <!-- Skeleton Loading State for Preview -->
          <div id="import-preview-skeleton" class="skeleton-container hidden">
            <div class="skeleton-stat-row">
              <div class="skeleton-item skeleton-stat"></div>
              <div class="skeleton-item skeleton-stat"></div>
            </div>
            <div class="skeleton-stat-row">
              <div class="skeleton-item skeleton-stat"></div>
              <div class="skeleton-item skeleton-stat"></div>
            </div>
            <div class="skeleton-item skeleton-tree-item"></div>
            <div class="skeleton-item skeleton-tree-item"></div>
            <div class="skeleton-item skeleton-tree-item"></div>
          </div>
          
          <!-- Order Tab Content -->
          <div id="import-order-panel" class="preview-tab-panel active" style="display: flex; flex-direction: column; height: 100%;">
            <div id="import-stats-section" class="preview-stats-scroll-container" style="display: none;">
              <div class="preview-scroll-fade-top" id="import-preview-stats-fade-top"></div>
              <div class="preview-scroll-fade-bottom" id="import-preview-stats-fade-bottom"></div>
              <div class="preview-stats-scroll-content" id="import-preview-stats-scroll-content">
                <div id="import-stats-summary"></div>
              </div>
            </div>
            <div id="import-empty-preview-order" class="empty-state" style="display: flex;">
              <span class="empty-icon">📊</span>
              <span>Load JSON to see stats</span>
            </div>
          </div>
          <!-- Tree Tab Content -->
          <div id="import-tree-panel" class="preview-tab-panel" style="display: none;">
            <div id="import-preview-tree-section" class="hidden" style="height: 100%; display: flex; flex-direction: column;">
              <div class="structure-tree" id="import-preview-tree" style="flex: 1;"></div>
            </div>
            <div id="import-empty-preview-tree" class="empty-state" style="display: flex;">
              <span class="empty-icon">🌲</span>
              <span>Load JSON to preview structure</span>
            </div>
          </div>
        </div>
        <!-- Persistent Footer with Import Button (matches Export footer) -->
        <div class="column-footer" style="background: #FFD93D;">
          <div id="import-library-option" class="footer-option hidden">
            <label class="form-checkbox form-checkbox-small">
              <input type="checkbox" id="import-use-library-refs" checked>
              <span>Restore library links (if connected)</span>
            </label>
          </div>
          <button class="btn btn-import btn-full" onclick="importVariables()" id="import-btn" disabled>
            📥 Import Selected
          </button>
          <p class="help-text" id="import-status" style="margin-top: 6px; text-align: center; font-family: var(--font-mono);">Load a JSON file to begin</p>
        </div>
      </div>
      
      <!-- Column 4: Activity Log (matches Export Activity Log column) -->
      <div class="column">
        <div class="column-header">
          <span class="column-title">📁 Activity Log</span>
          <div class="column-actions">
            <button class="btn btn-small btn-secondary" onclick="copyLog('import')">📋 Copy</button>
            <button class="btn btn-small btn-secondary" onclick="clearLog('import')">🗑️ Clear</button>
          </div>
        </div>
        <div class="column-body" style="display: flex; flex-direction: column; gap: 8px;">
          <div class="log-area" id="log-area-import" style="flex: 1; min-height: 120px;">
            <div class="log-entry">
              <span class="log-time">--:--:--</span>
              <span>Ready to import</span>
            </div>
          </div>
          <!-- Import Result Preview Section (appears after import) -->
          <div id="import-result-preview-section" class="json-preview-section hidden">
            <div class="json-preview-header">
              <span class="json-preview-title">📊 Import Results</span>
            </div>
            <div class="json-preview-body">
              <div class="import-result-stats" id="import-result-stats">
                <!-- Import stats will be populated here -->
              </div>
            </div>
          </div>
          <!-- Undo Import Section (appears after successful import) -->
          <div id="import-undo-section" class="import-undo-section hidden">
            <button class="btn btn-danger btn-full undo-import-btn" id="undo-import-btn" onclick="undoLastImport()">
              <span class="undo-icon">↩️</span> Undo Import
            </button>
            <span class="undo-hint">Restores file to state before import</span>
          </div>
        </div>
      </div>
      
    </div>
  </main>

  <!-- ============================================================
       FOOTER - 72px branding + actions
       ============================================================ -->
  <footer class="plugin-footer">
    <div class="footer-brand">
      Made with <span style="color: #FF4D4F;">❤️</span> by <span>The Keep Collective</span>
    </div>
    <div class="footer-actions">
      <button class="footer-btn footer-btn-tip" onclick="openTipModal()">☕ Buy me a coffee</button>
      <a href="https://shop.tusharkantnaik.com" target="_blank" class="footer-btn footer-btn-shop">🛒 Collector's Shop</a>
    </div>
  </footer>

  <!-- Hidden elements for compatibility -->
  <textarea id="export-output" style="display: none;"></textarea>
  <div id="log-area" style="display: none;"></div>

  <script>
    // ========== PERFORMANCE UTILITIES ==========
    
    // Debounce function to prevent excessive re-rendering
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }
    
    // Throttle function for scroll events
    function throttle(func, limit) {
      let inThrottle;
      return function(...args) {
        if (!inThrottle) {
          func.apply(this, args);
          inThrottle = true;
          setTimeout(() => inThrottle = false, limit);
        }
      };
    }
    
    // Request animation frame wrapper for smooth updates
    function rafUpdate(callback) {
      requestAnimationFrame(() => {
        callback();
      });
    }
    
    // Schedule work during idle time (or fallback to setTimeout)
    const scheduleIdle = window.requestIdleCallback 
      ? (cb, opts) => window.requestIdleCallback(cb, opts)
      : (cb) => setTimeout(cb, 1);
    
    // Cancel idle callback
    const cancelIdle = window.cancelIdleCallback 
      ? (id) => window.cancelIdleCallback(id)
      : (id) => clearTimeout(id);
    
    // ========== WEB WORKER FOR JSON PARSING ==========
    // Create inline Web Worker for heavy JSON operations (parsing & stringifying)
    const jsonWorkerBlob = new Blob([`
      self.onmessage = function(e) {
        const { id, type, data } = e.data;
        try {
          let result;
          if (type === 'parse') {
            result = JSON.parse(data);
          } else if (type === 'stringify') {
            result = JSON.stringify(data);
          }
          self.postMessage({ id, success: true, result });
        } catch (err) {
          self.postMessage({ id, success: false, error: err.message });
        }
      };
    `], { type: 'application/javascript' });
    
    let jsonWorker = null;
    let jsonWorkerCallbacks = new Map();
    let jsonWorkerId = 0;
    
    // Initialize worker lazily
    function getJSONWorker() {
      if (!jsonWorker) {
        try {
          jsonWorker = new Worker(URL.createObjectURL(jsonWorkerBlob));
          jsonWorker.onmessage = (e) => {
            const { id, success, result, error } = e.data;
            const callback = jsonWorkerCallbacks.get(id);
            if (callback) {
              jsonWorkerCallbacks.delete(id);
              if (success) {
                callback.resolve(result);
              } else {
                callback.reject(new Error(error));
              }
            }
          };
          jsonWorker.onerror = (err) => {
            console.warn('JSON Worker error, falling back to main thread:', err);
            jsonWorker = null;
          };
        } catch (e) {
          console.warn('Web Worker not available, using main thread');
          return null;
        }
      }
      return jsonWorker;
    }
    
    // ========== CACHING SYSTEM ==========
    const parseCache = new Map();
    const CACHE_MAX_SIZE = 10;
    const CACHE_MAX_AGE = 60000; // 1 minute
    
    // Simple hash function for cache keys
    function hashString(str) {
      let hash = 0;
      const len = Math.min(str.length, 10000); // Only hash first 10KB for speed
      for (let i = 0; i < len; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      // Include length in hash to differentiate similar prefixes
      return `${hash}_${str.length}`;
    }
    
    // Get from cache if valid
    function getCachedParse(jsonString) {
      const key = hashString(jsonString);
      const cached = parseCache.get(key);
      if (cached && (Date.now() - cached.timestamp < CACHE_MAX_AGE)) {
        return cached.data;
      }
      return null;
    }
    
    // Store in cache with LRU eviction
    function setCachedParse(jsonString, data) {
      const key = hashString(jsonString);
      
      // LRU eviction if cache is full
      if (parseCache.size >= CACHE_MAX_SIZE) {
        const oldestKey = parseCache.keys().next().value;
        parseCache.delete(oldestKey);
      }
      
      parseCache.set(key, { data, timestamp: Date.now() });
    }
    
    // Clear cache (call when data changes significantly)
    function clearParseCache() {
      parseCache.clear();
    }
    
    // ========== ASYNC JSON OPERATIONS ==========
    // Async JSON parser using Web Worker for large data
    async function parseJSONAsync(jsonString) {
      // Check cache first
      const cached = getCachedParse(jsonString);
      if (cached) {
        return cached;
      }
      
      return new Promise((resolve, reject) => {
        // For small JSON (<50KB), parse directly on main thread
        if (jsonString.length < 50000) {
          try {
            const result = JSON.parse(jsonString);
            setCachedParse(jsonString, result);
            resolve(result);
          } catch (e) {
            reject(e);
          }
          return;
        }
        
        // For medium JSON (50KB-500KB), use idle callback
        if (jsonString.length < 500000) {
          scheduleIdle(() => {
            try {
              const result = JSON.parse(jsonString);
              setCachedParse(jsonString, result);
              resolve(result);
            } catch (e) {
              reject(e);
            }
          }, { timeout: 100 });
          return;
        }
        
        // For large JSON (>500KB), try Web Worker
        const worker = getJSONWorker();
        if (worker) {
          const id = ++jsonWorkerId;
          jsonWorkerCallbacks.set(id, { 
            resolve: (result) => {
              setCachedParse(jsonString, result);
              resolve(result);
            }, 
            reject 
          });
          
          // Set timeout for worker response
          setTimeout(() => {
            if (jsonWorkerCallbacks.has(id)) {
              jsonWorkerCallbacks.delete(id);
              // Fallback to main thread
              scheduleIdle(() => {
                try {
                  const result = JSON.parse(jsonString);
                  setCachedParse(jsonString, result);
                  resolve(result);
                } catch (e) {
                  reject(e);
                }
              }, { timeout: 200 });
            }
          }, 5000);
          
          worker.postMessage({ id, type: 'parse', data: jsonString });
        } else {
          // Fallback: use idle callback
          scheduleIdle(() => {
            try {
              const result = JSON.parse(jsonString);
              setCachedParse(jsonString, result);
              resolve(result);
            } catch (e) {
              reject(e);
            }
          }, { timeout: 200 });
        }
      });
    }
    
    // Async JSON stringify using Web Worker for large data
    async function stringifyJSONAsync(data) {
      return new Promise((resolve, reject) => {
        // Quick size estimation
        const isLarge = Array.isArray(data) && data.length > 100;
        
        // For small data, stringify directly
        if (!isLarge) {
          try {
            resolve(JSON.stringify(data));
          } catch (e) {
            reject(e);
          }
          return;
        }
        
        // For large data, try Web Worker
        const worker = getJSONWorker();
        if (worker) {
          const id = ++jsonWorkerId;
          jsonWorkerCallbacks.set(id, { resolve, reject });
          
          // Set timeout for worker response
          setTimeout(() => {
            if (jsonWorkerCallbacks.has(id)) {
              jsonWorkerCallbacks.delete(id);
              // Fallback to main thread
              try {
                resolve(JSON.stringify(data));
              } catch (e) {
                reject(e);
              }
            }
          }, 5000);
          
          worker.postMessage({ id, type: 'stringify', data });
        } else {
          // Fallback: stringify on main thread with idle callback
          scheduleIdle(() => {
            try {
              resolve(JSON.stringify(data));
            } catch (e) {
              reject(e);
            }
          }, { timeout: 100 });
        }
      });
    }
    
    // Batch DOM updates using DocumentFragment
    function batchDOMUpdate(container, htmlContent) {
      rafUpdate(() => {
        container.innerHTML = htmlContent;
      });
    }
    
    // Process array in chunks to avoid blocking UI
    async function processInChunks(array, processFn, chunkSize = 50) {
      const results = [];
      for (let i = 0; i < array.length; i += chunkSize) {
        const chunk = array.slice(i, i + chunkSize);
        const chunkResults = chunk.map(processFn);
        results.push(...chunkResults);
        
        // Yield to browser between chunks
        if (i + chunkSize < array.length) {
          await new Promise(resolve => rafUpdate(resolve));
        }
      }
      return results;
    }
    
    // Efficient object flattening with early termination option
    function flattenObjectFast(obj, prefix = '', maxDepth = 20) {
      const results = [];
      const stack = [{ obj, prefix, depth: 0 }];
      
      while (stack.length > 0) {
        const { obj: current, prefix: currentPrefix, depth } = stack.pop();
        
        if (depth > maxDepth) continue;
        
        for (const key of Object.keys(current)) {
          if (key.startsWith('$')) continue;
          
          const value = current[key];
          const newPath = currentPrefix ? `${currentPrefix}/${key}` : key;
          
          if (value && typeof value === 'object' && !Array.isArray(value)) {
            if (value.$type) {
              results.push({ path: newPath, value });
            } else {
              stack.push({ obj: value, prefix: newPath, depth: depth + 1 });
            }
          }
        }
      }
      
      return results;
    }
    
    // Clear the file loaded indicator in drop zone
    function clearFileLoadedIndicator() {
      const fileInput = document.getElementById('file-input');
      if (fileInput) fileInput.value = '';
      
      // Hide the loaded file indicator
      const fileLoadedIndicator = document.getElementById('import-file-loaded');
      if (fileLoadedIndicator) {
        fileLoadedIndicator.classList.add('hidden');
      }
      
      // Hide the import result preview section
      const resultPreview = document.getElementById('import-result-preview-section');
      if (resultPreview) {
        resultPreview.classList.add('hidden');
      }
      
      // Hide import compatibility banners
      const compatBanner = document.getElementById('import-compatibility-banner');
      const extDepsBanner = document.getElementById('import-external-deps-banner');
      if (compatBanner) compatBanner.classList.add('hidden');
      if (extDepsBanner) extDepsBanner.classList.add('hidden');
    }

    // Clear import input area
    function clearImportInput() {
      const importInput = document.getElementById('import-input');
      if (importInput) importInput.value = '';
      importData = null;
      libraryStatus = null;
      fontStatus = null;
      importWithLibraryLinks = true;
      clearFileLoadedIndicator();
      
      // Clear parse cache when input is cleared
      clearParseCache();
      
      // Hide skeletons if visible
      const statusSkeleton = document.getElementById('import-status-skeleton');
      const previewSkeleton = document.getElementById('import-preview-skeleton');
      if (statusSkeleton) statusSkeleton.classList.add('hidden');
      if (previewSkeleton) previewSkeleton.classList.add('hidden');
      
      // Reset UI - hide content, show empty states
      const statsSection = document.getElementById('import-stats-section');
      const treeSection = document.getElementById('import-preview-tree-section');
      const orderEmptyPreview = document.getElementById('import-empty-preview-order');
      const treeEmptyPreview = document.getElementById('import-empty-preview-tree');
      const totalHeader = document.getElementById('import-stats-total-header');
      
      if (statsSection) statsSection.style.display = 'none';
      if (treeSection) treeSection.classList.add('hidden');
      if (orderEmptyPreview) orderEmptyPreview.style.display = 'flex';
      if (treeEmptyPreview) treeEmptyPreview.style.display = 'flex';
      if (totalHeader) totalHeader.classList.add('hidden');
      
      const planSection = document.getElementById('plan-selection-section');
      if (planSection) planSection.classList.add('hidden');
      document.getElementById('import-validation-empty').classList.remove('hidden');
      document.getElementById('import-btn').disabled = true;
      document.getElementById('import-status').textContent = 'Load a JSON file to begin';
      
      // Disable Clear button
      const clearBtn = document.getElementById('import-clear-btn');
      if (clearBtn) clearBtn.disabled = true;
      
      // Hide plan detection sections (only source-related, not Figma file plan)
      const sourcePlanSection = document.getElementById('source-json-plan-section');
      const planMismatchWarning = document.getElementById('plan-mismatch-warning');
      const planCompatSection = document.getElementById('plan-compatibility-section');
      const preProceedSections = document.getElementById('import-pre-proceed-sections');
      if (sourcePlanSection) sourcePlanSection.classList.add('hidden');
      if (planMismatchWarning) planMismatchWarning.classList.add('hidden');
      if (planCompatSection) planCompatSection.classList.add('hidden');
      if (preProceedSections) {
        preProceedSections.classList.add('hidden');
        preProceedSections.style.display = 'flex';  // Restore flex so gap works when shown again
      }
      // Note: Don't reset Figma plan accordion - it's based on the Figma file, not the JSON
      
      // Reset proceed button
      const proceedBtn = document.getElementById('import-proceed-btn');
      if (proceedBtn) proceedBtn.disabled = true;
      
      // Reset two-faced column to input face
      const inputFace = document.getElementById('import-input-face');
      const selectionFace = document.getElementById('import-selection-face');
      const trashBtn = document.getElementById('import-trash-btn');
      if (inputFace) inputFace.style.display = '';  // Restore CSS flex display
      if (selectionFace) selectionFace.style.display = 'none';
      if (trashBtn) trashBtn.style.display = 'none';
      
      // Clear stored parsed data
      parsedImportCollections = [];
      parsedImportStyles = null;
      selectedImportCollections.clear();
      
      // Reset import images option
      const importImagesOption = document.getElementById('import-images-option');
      const importIncludeImages = document.getElementById('import-include-images');
      if (importImagesOption) importImagesOption.style.display = 'none';
      if (importIncludeImages) {
        importIncludeImages.checked = true;
        importIncludeImages.disabled = false;
      }
      
      // Hide library and font status sections (both pre-proceed and post-proceed)
      const libSection = document.getElementById('library-status-section');
      const libSectionPre = document.getElementById('library-status-section-pre');
      const fontSection = document.getElementById('font-status-section');
      const fontSectionPre = document.getElementById('font-status-section-pre');
      if (libSection) libSection.classList.add('hidden');
      if (libSectionPre) libSectionPre.classList.add('hidden');
      if (fontSection) fontSection.classList.add('hidden');
      if (fontSectionPre) fontSectionPre.classList.add('hidden');
      
      // Hide import asset source and bindings info banners
      const importAssetSourceBanner = document.getElementById('import-asset-source-banner');
      const importBindingsBanner = document.getElementById('import-bindings-info-banner');
      if (importAssetSourceBanner) importAssetSourceBanner.classList.add('hidden');
      if (importBindingsBanner) importBindingsBanner.classList.add('hidden');
      
      // Clear import diff data
      lastImportDiff = null;
      
      // Hide the validate footer (Review Changes accordion)
      const validateFooter = document.getElementById('import-validate-footer');
      if (validateFooter) validateFooter.style.display = 'none';
      
      // Reset importPreviewReviewed flag
      importPreviewReviewed = false;
      
      // Hide scroll fades for import columns
      const importFades = [
        'import-input-fade-top', 'import-input-fade-bottom',
        'import-status-fade-top', 'import-status-fade-bottom'
      ];
      importFades.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.classList.remove('visible');
      });
      
      addLog('🗑️ Input cleared', 'info', 'import');
    }

    // Store parsed import data for use when proceeding to selection
    let parsedImportCollections = [];
    let parsedImportStyles = null;
    
    // Store import diff data for selection-aware counts
    let lastImportDiff = null;

    // Check if a collection exists in the target file
    function collectionExistsInTarget(collectionName) {
      return collections.some(col => col.name === collectionName);
    }

    // Get list of target collection names for quick lookup
    function getTargetCollectionNames() {
      return new Set(collections.map(col => col.name));
    }

    // Render import collections list with optional Advanced mode controls
    function renderImportCollectionsList() {
      const collectionsList = document.getElementById('import-collections-list');
      if (!collectionsList) return;
      
      const targetCollectionNames = getTargetCollectionNames();
      
      const collectionsHtml = parsedImportCollections.map((colObj, idx) => {
        const colName = Object.keys(colObj)[0];
        const col = colObj[colName];
        const modes = Object.keys(col.modes || {});
        
        // Count variables and types
        let varCount = 0;
        const types = { color: 0, float: 0, boolean: 0, string: 0 };
        
        modes.forEach(mode => {
          const modeVars = col.modes[mode];
          const flatVars = flattenObject(modeVars);
          varCount = Math.max(varCount, flatVars.length);
          flatVars.forEach(v => {
            if (v.$type) types[v.$type]++;
          });
        });
        
        // Normalize type counts
        Object.keys(types).forEach(t => {
          types[t] = Math.round(types[t] / Math.max(modes.length, 1));
        });
        
        const isChecked = selectedImportCollections.has(colName);
        const currentBehavior = getCollectionBehavior(colName);
        
        // Check if collection exists in target file
        const existsInTarget = targetCollectionNames.has(colName);
        
        // Advanced mode: only show dropdown for collections that exist in target
        let advancedControls = '';
        if (isAdvancedMode() && existsInTarget) {
          advancedControls = `
            <select class="collection-behavior-dropdown" 
                    onclick="event.stopPropagation()" 
                    onchange="setCollectionBehavior('${colName}', this.value)">
              <option value="merge" ${currentBehavior === 'merge' ? 'selected' : ''}>Merge</option>
              <option value="replace" ${currentBehavior === 'replace' ? 'selected' : ''}>Replace</option>
            </select>
          `;
        }
        
        // Show "NEW" badge for collections that don't exist in target
        const newBadge = !existsInTarget ? '<span class="collection-new-badge">NEW</span>' : '';

        return `
          <div class="collection-item ${isAdvancedMode() && existsInTarget ? 'collection-item-advanced' : ''}" onclick="toggleImportCollection('${colName}')">
            <input type="checkbox" class="collection-checkbox" id="import-col-${idx}" ${isChecked ? 'checked' : ''} 
                   onclick="event.stopPropagation()" onchange="updateImportSelection('${colName}', this.checked)">
            <div class="collection-info">
              <div class="collection-name">${colName} ${newBadge}</div>
              <div class="collection-meta">~${varCount} variables • Modes: ${modes.join(', ')}</div>
              <div class="collection-types">
                ${types.color > 0 ? `<span class="type-badge type-color">${types.color} colors</span>` : ''}
                ${types.float > 0 ? `<span class="type-badge type-float">${types.float} numbers</span>` : ''}
                ${types.boolean > 0 ? `<span class="type-badge type-boolean">${types.boolean} booleans</span>` : ''}
                ${types.string > 0 ? `<span class="type-badge type-string">${types.string} strings</span>` : ''}
              </div>
            </div>
            ${advancedControls}
          </div>
        `;
      }).join('');
      
      collectionsList.innerHTML = collectionsHtml;
    }

    // Proceed to selection face (flip column)
    function proceedToImportSelection() {
      const inputFace = document.getElementById('import-input-face');
      const selectionFace = document.getElementById('import-selection-face');
      const trashBtn = document.getElementById('import-trash-btn');
      const proceedFooter = document.getElementById('import-proceed-footer');
      const selectionFooter = document.getElementById('import-selection-footer');
      const collectionsList = document.getElementById('import-collections-list');
      const stylesSection = document.getElementById('import-styles-section');
      const stylesOptions = document.getElementById('import-styles-options');
      const preProceedSections = document.getElementById('import-pre-proceed-sections');
      const postProceedSections = document.getElementById('import-post-proceed-sections');
      const validateFooter = document.getElementById('import-validate-footer');
      const importDiffAccordion = document.getElementById('import-diff-accordion');
      
      // Hide input face, show selection face
      if (inputFace) inputFace.style.display = 'none';
      if (selectionFace) selectionFace.style.display = '';  // Restore CSS flex display
      if (trashBtn) trashBtn.style.display = 'flex';
      // Hide proceed footer, show selection footer
      if (proceedFooter) proceedFooter.style.display = 'none';
      if (selectionFooter) selectionFooter.classList.remove('is-hidden');  // Remove hidden class
      
      // Show the Import Preview footer on Check & Validate column
      if (validateFooter) validateFooter.style.display = '';
      // Close the accordion and reset review state
      if (importDiffAccordion) importDiffAccordion.open = false;
      importPreviewReviewed = false;
      
      // Switch Check & Validate sections
      if (preProceedSections) preProceedSections.style.display = 'none';
      if (postProceedSections) postProceedSections.classList.remove('hidden');
      
      // Populate collections list
      selectedImportCollections.clear();
      
      // Initialize all collections as selected
      parsedImportCollections.forEach((colObj) => {
        const colName = Object.keys(colObj)[0];
        selectedImportCollections.add(colName);
        // Initialize behavior to 'merge' by default
        if (!collectionBehaviors.has(colName)) {
          collectionBehaviors.set(colName, 'merge');
        }
      });
      
      // Render collections list (supports Advanced mode)
      renderImportCollectionsList();
      
      // Populate styles section if styles exist
      if (parsedImportStyles && stylesSection && stylesOptions) {
        const totalColorStyles = parsedImportStyles.colorStyles?.length || 0;
        const totalTextStyles = parsedImportStyles.textStyles?.length || 0;
        const totalEffectStyles = parsedImportStyles.effectStyles?.length || 0;
        const totalGridStyles = parsedImportStyles.gridStyles?.length || 0;
        const totalStyles = totalColorStyles + totalTextStyles + totalEffectStyles + totalGridStyles;
        
        if (totalStyles > 0) {
          let stylesHtml = '';
          if (totalTextStyles > 0) {
            stylesHtml += `
              <label class="form-checkbox">
                <input type="checkbox" id="import-text-styles-sel" checked onclick="event.stopPropagation()" onchange="updateImportStyleSelection()">
                <span class="style-name">✏️ Text Styles</span>
                <span class="style-count">(${totalTextStyles})</span>
              </label>`;
          }
          if (totalColorStyles > 0) {
            stylesHtml += `
              <label class="form-checkbox">
                <input type="checkbox" id="import-color-styles-sel" checked onclick="event.stopPropagation()" onchange="updateImportStyleSelection()">
                <span class="style-name">🎨 Colour Styles</span>
                <span class="style-count">(${totalColorStyles})</span>
              </label>`;
            
            // Check if color styles have image data
            const hasImageData = parsedImportStyles.colorStyles?.some(style => {
              if (style.paints) {
                return style.paints.some(paint => paint.type === 'IMAGE' && paint.imageBase64);
              }
              return false;
            });
            
            // Check if there are any IMAGE type paints without base64
            const hasImagePaintsWithoutData = parsedImportStyles.colorStyles?.some(style => {
              if (style.paints) {
                return style.paints.some(paint => paint.type === 'IMAGE' && !paint.imageBase64);
              }
              return false;
            });
            
            // Show import images option for advanced users
            const importImagesOption = document.getElementById('import-images-option');
            const importIncludeImages = document.getElementById('import-include-images');
            const importImagesInfoText = document.getElementById('import-images-info-text');
            
            if (importImagesOption && importImagesInfoText) {
              if (hasImageData) {
                // JSON has image data - show checkbox to let user choose
                importImagesOption.style.display = '';
                if (importIncludeImages) importIncludeImages.checked = true;
                importImagesInfoText.textContent = '✅ Image data available in JSON';
                importImagesInfoText.style.color = 'var(--color-success, #52c41a)';
              } else if (hasImagePaintsWithoutData) {
                // JSON has image styles but no data - show warning, disable checkbox
                importImagesOption.style.display = '';
                if (importIncludeImages) {
                  importIncludeImages.checked = false;
                  importIncludeImages.disabled = true;
                }
                importImagesInfoText.textContent = '⚠️ Image data not exported - image styles will be skipped';
                importImagesInfoText.style.color = 'var(--color-warning, #faad14)';
              } else {
                // No image styles at all - hide option
                importImagesOption.style.display = 'none';
              }
            }
          }
          if (totalEffectStyles > 0) {
            stylesHtml += `
              <label class="form-checkbox">
                <input type="checkbox" id="import-effect-styles-sel" checked onclick="event.stopPropagation()" onchange="updateImportStyleSelection()">
                <span class="style-name">✨ Effect Styles</span>
                <span class="style-count">(${totalEffectStyles})</span>
              </label>`;
          }
          if (totalGridStyles > 0) {
            stylesHtml += `
              <label class="form-checkbox">
                <input type="checkbox" id="import-grid-styles-sel" checked onclick="event.stopPropagation()" onchange="updateImportStyleSelection()">
                <span class="style-name">📐 Layout Guides</span>
                <span class="style-count">(${totalGridStyles})</span>
              </label>`;
          }
          
          stylesOptions.innerHTML = stylesHtml;
          stylesSection.style.display = 'block';
        } else {
          stylesSection.style.display = 'none';
          // Hide import images option if no styles
          const importImagesOption = document.getElementById('import-images-option');
          if (importImagesOption) importImagesOption.style.display = 'none';
        }
      } else if (stylesSection) {
        stylesSection.style.display = 'none';
        // Hide import images option if no styles section
        const importImagesOption = document.getElementById('import-images-option');
        if (importImagesOption) importImagesOption.style.display = 'none';
      }
      
      // Import button remains disabled until user reviews the preview accordion
      // updateImportButtonState() will handle enabling it after accordion is opened
      
      // Update status text to prompt user to review
      const statusEl = document.getElementById('import-status');
      if (statusEl) {
        statusEl.textContent = `Review changes to import ${selectedImportCollections.size} collection(s)`;
      }
      
      // Update source JSON plan banner
      updateSourceJsonPlanBanner();
      
      // Trigger plan detection for target file
      parent.postMessage({ pluginMessage: { type: 'detect_plan' } }, '*');
      
      // Re-validate now that we're on selection face
      if (importData) {
        validateImport();
      }
      
      addLog('▶️ Proceeded to selection', 'success', 'import');
    }

    // Reset import to input face (trash button)
    function resetImportToInputFace() {
      const inputFace = document.getElementById('import-input-face');
      const selectionFace = document.getElementById('import-selection-face');
      const trashBtn = document.getElementById('import-trash-btn');
      const proceedFooter = document.getElementById('import-proceed-footer');
      const selectionFooter = document.getElementById('import-selection-footer');
      const preProceedSections = document.getElementById('import-pre-proceed-sections');
      const postProceedSections = document.getElementById('import-post-proceed-sections');
      const importImagesOption = document.getElementById('import-images-option');
      const validateFooter = document.getElementById('import-validate-footer');
      
      // Show input face, hide selection face
      if (inputFace) inputFace.style.display = '';  // Restore CSS flex display
      if (selectionFace) selectionFace.style.display = 'none';
      if (trashBtn) trashBtn.style.display = 'none';
      // Show proceed footer, hide selection footer
      if (proceedFooter) proceedFooter.style.display = '';  // Restore CSS display
      if (selectionFooter) selectionFooter.classList.add('is-hidden');  // Add hidden class
      
      // Reset Check & Validate sections
      if (preProceedSections) preProceedSections.style.display = '';
      if (postProceedSections) postProceedSections.classList.add('hidden');
      
      // Hide import images option
      if (importImagesOption) importImagesOption.style.display = 'none';
      
      // Hide Import Preview footer and reset review state
      if (validateFooter) validateFooter.style.display = 'none';
      importPreviewReviewed = false;
      
      // Clear all import data
      clearImportInput();
      
      // Reset proceed button
      const proceedBtn = document.getElementById('import-proceed-btn');
      if (proceedBtn) proceedBtn.disabled = true;
      
      // Clear stored parsed data
      parsedImportCollections = [];
      parsedImportStyles = null;
      
      // Clear per-collection behaviors (Advanced mode)
      collectionBehaviors.clear();
      
      addLog('🗑️ Reset to input - cleared all', 'info', 'import');
    }

    // Select all import collections
    function selectAllImport(select) {
      const collectionsList = document.getElementById('import-collections-list');
      if (!collectionsList) return;
      
      const checkboxes = collectionsList.querySelectorAll('.collection-checkbox');
      checkboxes.forEach(checkbox => {
        checkbox.checked = select;
        const colName = checkbox.closest('.collection-item')?.querySelector('.collection-name')?.textContent;
        if (colName) {
          if (select) {
            selectedImportCollections.add(colName);
          } else {
            selectedImportCollections.delete(colName);
          }
        }
      });
      
      updateImportButtonState();
    }

    // Select all import styles
    function selectAllImportStyles(select) {
      const styleCheckboxes = document.querySelectorAll('#import-styles-options input[type="checkbox"]');
      styleCheckboxes.forEach(checkbox => {
        checkbox.checked = select;
      });
      updateImportStyleSelection();
    }

    // Update import style selection state
    function updateImportStyleSelection() {
      updateImportButtonState();
      updateImportPreviewStats();
    }
    
    // Update preview stats based on current selection
    function updateImportPreviewStats() {
      if (!parsedImportCollections || parsedImportCollections.length === 0) return;
      
      // Calculate variable stats for selected collections only
      let totalVariables = 0;
      let totalColors = 0;
      let totalNumbers = 0;
      let totalStrings = 0;
      let totalBooleans = 0;
      let totalCollections = 0;
      
      parsedImportCollections.forEach(colObj => {
        const colName = Object.keys(colObj)[0];
        // Only count if collection is selected
        if (!selectedImportCollections.has(colName)) return;
        
        totalCollections++;
        const col = colObj[colName];
        const modes = Object.keys(col.modes || {});
        
        // Count variables and types (same logic as parseImportPreview)
        let varCount = 0;
        const types = { color: 0, float: 0, boolean: 0, string: 0 };
        
        modes.forEach(mode => {
          const modeVars = col.modes[mode];
          const flatVars = flattenObject(modeVars);
          varCount = Math.max(varCount, flatVars.length);
          flatVars.forEach(v => {
            if (v.$type) types[v.$type]++;
          });
        });
        
        // Normalize type counts (don't multiply by modes)
        Object.keys(types).forEach(t => {
          types[t] = Math.round(types[t] / Math.max(modes.length, 1));
        });
        
        totalVariables += varCount;
        totalColors += types.color;
        totalNumbers += types.float;
        totalStrings += types.string;
        totalBooleans += types.boolean;
      });
      
      // Calculate style stats based on selected style checkboxes
      let totalColorStyles = 0;
      let totalTextStyles = 0;
      let totalEffectStyles = 0;
      let totalGridStyles = 0;
      
      if (parsedImportStyles) {
        const colorStylesCheck = document.getElementById('import-color-styles-sel');
        const textStylesCheck = document.getElementById('import-text-styles-sel');
        const effectStylesCheck = document.getElementById('import-effect-styles-sel');
        const gridStylesCheck = document.getElementById('import-grid-styles-sel');
        
        if (colorStylesCheck?.checked) totalColorStyles = parsedImportStyles.colorStyles?.length || 0;
        if (textStylesCheck?.checked) totalTextStyles = parsedImportStyles.textStyles?.length || 0;
        if (effectStylesCheck?.checked) totalEffectStyles = parsedImportStyles.effectStyles?.length || 0;
        if (gridStylesCheck?.checked) totalGridStyles = parsedImportStyles.gridStyles?.length || 0;
      }
      
      const totalStyles = totalColorStyles + totalTextStyles + totalEffectStyles + totalGridStyles;
      
      // Update the stats summary HTML
      const statsSummary = document.getElementById('import-stats-summary');
      if (!statsSummary) return;
      
      let statsHtml = '';
      
      // Variables section
      if (totalCollections > 0) {
        statsHtml += `
          <div class="stats-section">
            <div class="stats-section-title">📦 Variables</div>
            <div class="stats-row">
              <div class="stat-card">
                <span class="stat-value">${totalColors}</span>
                <span class="stat-label">Colors</span>
              </div>
              <div class="stat-card">
                <span class="stat-value">${totalNumbers}</span>
                <span class="stat-label">Numbers</span>
              </div>
            </div>
            <div class="stats-row">
              <div class="stat-card">
                <span class="stat-value">${totalStrings}</span>
                <span class="stat-label">Strings</span>
              </div>
              <div class="stat-card">
                <span class="stat-value">${totalBooleans}</span>
                <span class="stat-label">Booleans</span>
              </div>
            </div>
            <div class="stats-row">
              <div class="stat-card">
                <span class="stat-value">${totalCollections}</span>
                <span class="stat-label">Collections</span>
              </div>
              <div class="stat-card stat-total">
                <span class="stat-value">${totalVariables}</span>
                <span class="stat-label">Total</span>
              </div>
            </div>
          </div>
        `;
      } else {
        statsHtml += `
          <div class="stats-section">
            <div class="stats-section-title">📦 Variables</div>
            <div class="stats-row">
              <div class="stat-card stat-empty">
                <span class="stat-value">0</span>
                <span class="stat-label">No collections selected</span>
              </div>
            </div>
          </div>
        `;
      }
      
      // Styles section
      if (totalStyles > 0) {
        statsHtml += `
          <div class="stats-section">
            <div class="stats-section-title">🎨 Styles</div>
            <div class="stats-row stats-row-3col">
              <div class="stat-card">
                <span class="stat-value">${totalTextStyles}</span>
                <span class="stat-label">Text</span>
              </div>
              <div class="stat-card">
                <span class="stat-value">${totalColorStyles}</span>
                <span class="stat-label">Color</span>
              </div>
              <div class="stat-card">
                <span class="stat-value">${totalEffectStyles}</span>
                <span class="stat-label">Effect</span>
              </div>
            </div>
            <div class="stats-row">
              <div class="stat-card">
                <span class="stat-value">${totalGridStyles}</span>
                <span class="stat-label">Layout Guide</span>
              </div>
              <div class="stat-card stat-total">
                <span class="stat-value">${totalStyles}</span>
                <span class="stat-label">Total</span>
              </div>
            </div>
          </div>
        `;
      } else if (parsedImportStyles) {
        statsHtml += `
          <div class="stats-section">
            <div class="stats-section-title">🎨 Styles</div>
            <div class="stats-row">
              <div class="stat-card stat-empty">
                <span class="stat-value">0</span>
                <span class="stat-label">No styles selected</span>
              </div>
            </div>
          </div>
        `;
      }
      
      statsSummary.innerHTML = statsHtml;
      
      // Update total header
      const totalItems = totalVariables + totalStyles;
      const totalValueEl = document.getElementById('import-total-value');
      const totalHeader = document.getElementById('import-stats-total-header');
      if (totalValueEl) totalValueEl.textContent = totalItems;
      if (totalHeader) {
        if (totalItems > 0) {
          totalHeader.classList.remove('hidden');
        } else {
          totalHeader.classList.add('hidden');
        }
      }
      
      // Also update Review Changes counts based on selection
      updateReviewChangesCounts();
    }

    // Update import button state based on selections
    function updateImportButtonState() {
      const importBtn = document.getElementById('import-btn');
      const statusEl = document.getElementById('import-status');
      
      const hasCollections = selectedImportCollections.size > 0;
      const styleCheckboxes = document.querySelectorAll('#import-styles-options input[type="checkbox"]:checked');
      const hasStyles = styleCheckboxes.length > 0;
      
      if (importBtn) {
        // Require both: items selected AND preview reviewed (accordion opened)
        const hasItems = hasCollections || hasStyles;
        importBtn.disabled = !hasItems || !importPreviewReviewed;
      }
      
      if (statusEl) {
        if (hasCollections || hasStyles) {
          let statusText = '';
          if (hasCollections) statusText += `${selectedImportCollections.size} collection(s)`;
          if (hasCollections && hasStyles) statusText += ' + ';
          if (hasStyles) statusText += `${styleCheckboxes.length} style type(s)`;
          
          if (!importPreviewReviewed) {
            statusEl.textContent = `Review changes to import ${statusText}`;
          } else {
            statusEl.textContent = `Ready to import ${statusText}`;
          }
        } else {
          statusEl.textContent = 'Select items to import';
        }
      }
    }

    // Paste from clipboard - focuses textarea for user to paste
    function pasteFromClipboard() {
      const importInput = document.getElementById('import-input');
      if (importInput) {
        importInput.focus();
        importInput.select(); // Select any existing content
        addLog('📋 Ready to paste - use Ctrl/Cmd+V', 'info', 'import');
      }
    }

    // Copy log contents
    function copyLog(tab) {
      const logArea = document.getElementById(`log-area-${tab}`);
      if (logArea) {
        const text = Array.from(logArea.querySelectorAll('.log-entry'))
          .map(entry => entry.textContent)
          .join('\n');
        navigator.clipboard.writeText(text);
        addLog('📋 Log copied to clipboard', 'success', tab);
      }
    }

    // Clear log
    function clearLog(tab) {
      const logArea = document.getElementById(`log-area-${tab}`);
      if (logArea) {
        logArea.innerHTML = `<div class="log-entry"><span class="log-time">${getTime()}</span><span>Log cleared</span></div>`;
      }
    }

    // Get current time string
    function getTime() {
      return new Date().toLocaleTimeString('en-GB', { hour12: false });
    }
    
    // Optimized debounced version of parseImportPreview for large JSON input
    // Shows skeleton immediately, debounces only the heavy async parsing
    const debouncedParseImportPreview = (() => {
      let parseTimeoutId = null;
      
      return function() {
        // Clear file indicator when user manually types/pastes
        clearFileLoadedIndicator();
        
        // Show skeletons IMMEDIATELY for instant feedback (no debounce)
        showImportSkeletons();
        
        // Debounce only the heavy async parsing
        if (parseTimeoutId) {
          clearTimeout(parseTimeoutId);
        }
        parseTimeoutId = setTimeout(() => {
          parseTimeoutId = null;
          parseImportPreviewAsync();
        }, 150);
      };
    })();
    
    // Show loading skeletons immediately for instant UI feedback
    function showImportSkeletons() {
      const data = document.getElementById('import-input').value.trim();
      const statusSkeleton = document.getElementById('import-status-skeleton');
      const previewSkeleton = document.getElementById('import-preview-skeleton');
      const orderEmptyPreview = document.getElementById('import-empty-preview-order');
      const treeEmptyPreview = document.getElementById('import-empty-preview-tree');
      
      if (!data) {
        // Handle empty state synchronously for instant response
        handleEmptyImportState();
        return;
      }
      
      // Enable Clear button immediately
      const clearBtn = document.getElementById('import-clear-btn');
      if (clearBtn) clearBtn.disabled = false;
      
      // Show skeletons immediately while parsing
      if (statusSkeleton) {
        statusSkeleton.classList.remove('hidden');
        const validationEmpty = document.getElementById('import-validation-empty');
        const validationResults = document.getElementById('validation-results');
        if (validationEmpty) validationEmpty.classList.add('hidden');
        if (validationResults) validationResults.innerHTML = '';
      }
      if (previewSkeleton) {
        previewSkeleton.classList.remove('hidden');
        if (orderEmptyPreview) orderEmptyPreview.style.display = 'none';
        if (treeEmptyPreview) treeEmptyPreview.style.display = 'none';
      }
    }
    
    // ========== STATE ==========
    let collections = [];
    let stylesInfo = { colorStyles: 0, textStyles: 0, effectStyles: 0, gridStyles: 0 };
    let importData = null;
    let exportData = '';
    let selectedExportCollections = new Set();
    let selectedImportCollections = new Set();
    let selectedPlan = 'professional'; // Default plan
    let detectedPlan = 'professional'; // Plan detected from file
    let lastValidation = null;
    let selectedModes = {}; // { collectionName: Set of selected mode names }
    let collectionModes = {}; // { collectionName: [array of mode names] }
    let libraryStatus = null; // { allAvailable, availableCollections, missingCollections }
    let importWithLibraryLinks = true; // Default to try library links
    let fontStatus = null; // { allAvailable, availableFonts, missingFonts }
    let importPreviewReviewed = false; // Must review import preview before importing
    let lastImportSnapshot = null; // Snapshot of file state before import for undo

    // Plan limits (mirror of backend constants)
    const PLAN_LIMITS = {
      starter: { maxModes: 1, name: 'Starter', detail: '1 mode only (no multi-mode)' },
      professional: { maxModes: 10, name: 'Professional', detail: 'Up to 10 modes per collection' },
      organization: { maxModes: 20, name: 'Organization', detail: 'Up to 20 modes per collection' },
      enterprise: { maxModes: Infinity, name: 'Enterprise', detail: 'Unlimited modes' }
    };

    // Plan selection
    function selectPlan(plan) {
      selectedPlan = plan;
      document.querySelectorAll('.plan-option').forEach(el => {
        el.classList.toggle('selected', el.dataset.plan === plan);
      });
      
      // Update Figma file plan accordion with manual selection
      updateFigmaPlanAccordion(plan);
      
      // Reset selected modes when plan changes
      selectedModes = {};
      
      // Re-check plan mismatch
      checkPlanMismatch();
      
      // Re-validate with new plan
      if (importData) {
        validateImport();
      }
    }

    function handlePlanDetected(planData) {
      // Update Figma plan accordion
      updateFigmaPlanAccordion(planData.plan);
      
      // Auto-select detected plan
      selectedPlan = planData.plan;
      document.querySelectorAll('.plan-option').forEach(el => {
        el.classList.toggle('selected', el.dataset.plan === planData.plan);
      });
      addLog(`🎯 Figma file plan: ${PLAN_LIMITS[planData.plan].name} (based on existing collections)`, 'info', 'import');
      
      // Check for plan mismatch with source JSON
      checkPlanMismatch();
      
      // Re-validate with detected plan
      if (importData) {
        validateImport();
      }
    }
    
    // Detect source JSON plan based on max modes
    function detectSourceJsonPlan() {
      if (!parsedImportCollections || parsedImportCollections.length === 0) {
        return null;
      }
      
      let maxModes = 1;
      parsedImportCollections.forEach(colObj => {
        const colName = Object.keys(colObj)[0];
        const col = colObj[colName];
        const modes = Object.keys(col.modes || {});
        if (modes.length > maxModes) {
          maxModes = modes.length;
        }
      });
      
      // Determine plan based on max modes
      if (maxModes > 20) return 'enterprise';
      if (maxModes > 10) return 'organization';
      if (maxModes > 1) return 'professional';
      return 'starter';
    }
    
    // Update source JSON plan banner
    function updateSourceJsonPlanBanner() {
      const section = document.getElementById('source-json-plan-section');
      const preProceedSections = document.getElementById('import-pre-proceed-sections');
      const planValue = document.getElementById('source-plan-value');
      const planDetail = document.getElementById('source-plan-detail');
      
      if (!parsedImportCollections || parsedImportCollections.length === 0) {
        if (section) section.classList.add('hidden');
        return;
      }
      
      const sourcePlan = detectSourceJsonPlan();
      const planInfo = PLAN_LIMITS[sourcePlan];
      
      // Calculate max modes for display
      let maxModes = 1;
      parsedImportCollections.forEach(colObj => {
        const colName = Object.keys(colObj)[0];
        const col = colObj[colName];
        const modes = Object.keys(col.modes || {});
        if (modes.length > maxModes) maxModes = modes.length;
      });
      
      if (planValue) planValue.textContent = planInfo.name;
      if (planDetail) planDetail.textContent = `${maxModes} mode${maxModes > 1 ? 's' : ''} detected in source`;
      if (section) section.classList.remove('hidden');
      if (preProceedSections) preProceedSections.classList.remove('hidden');
      
      // Update plan compatibility after source plan is known
      updatePlanCompatibility();
      
      // Check for mismatch
      checkPlanMismatch();
    }
    
    // Update Figma File Plan accordion with detected plan
    function updateFigmaPlanAccordion(plan) {
      detectedPlan = plan;  // Set as the detected plan (single source of truth)
      
      const accordion = document.getElementById('figma-plan-accordion');
      const planValue = document.getElementById('figma-plan-value');
      
      if (!planValue || !accordion) return;
      
      const planInfo = PLAN_LIMITS[plan];
      planValue.textContent = planInfo.name;
      
      // Update the visual indicator rows for each plan tier
      const planOrder = ['starter', 'professional', 'organization', 'enterprise'];
      const currentPlanIndex = planOrder.indexOf(plan);
      
      planOrder.forEach((planKey, index) => {
        const row = accordion.querySelector(`.plan-modes-row[data-plan="${planKey}"]`);
        if (row) {
          row.classList.toggle('current-plan', planKey === plan);
          row.classList.toggle('available-plan', index <= currentPlanIndex);
        }
      });
      
      // Update plan compatibility after Figma plan is known
      updatePlanCompatibility();
    }
    
    // Update plan compatibility banner based on source JSON vs Figma file plan
    function updatePlanCompatibility() {
      const compatSection = document.getElementById('plan-compatibility-section');
      const compatBanner = document.getElementById('compatibility-banner');
      const compatIcon = document.getElementById('compatibility-icon');
      const compatStatus = document.getElementById('compatibility-text');
      const compatDesc = document.getElementById('compatibility-detail');
      
      if (!compatSection || !compatBanner) return;
      
      const sourcePlan = detectSourceJsonPlan();
      const figmaPlanValue = document.getElementById('figma-plan-value');
      const figmaPlanText = figmaPlanValue ? figmaPlanValue.textContent : null;
      
      // Get plan key from display name
      let figmaPlan = null;
      for (const [key, info] of Object.entries(PLAN_LIMITS)) {
        if (info.name === figmaPlanText) {
          figmaPlan = key;
          break;
        }
      }
      
      // If we don't have both plans yet, hide the section
      if (!sourcePlan || !figmaPlan || figmaPlanText === 'Detecting...') {
        compatSection.classList.add('hidden');
        return;
      }
      
      const planOrder = ['starter', 'professional', 'organization', 'enterprise'];
      const sourceIndex = planOrder.indexOf(sourcePlan);
      const figmaIndex = planOrder.indexOf(figmaPlan);
      const sourceInfo = PLAN_LIMITS[sourcePlan];
      const figmaInfo = PLAN_LIMITS[figmaPlan];
      
      // Show the section
      compatSection.classList.remove('hidden');
      compatBanner.classList.remove('compatible', 'incompatible', 'error');
      
      if (figmaIndex >= sourceIndex) {
        // Compatible - Figma plan supports the source JSON modes
        compatBanner.classList.add('compatible');
        compatIcon.textContent = '✅';
        compatStatus.textContent = 'Plans are compatible';
        compatDesc.textContent = `${figmaInfo.name} supports up to ${figmaInfo.maxModes} modes (source needs ${sourceInfo.maxModes})`;
      } else {
        // Incompatible - need mode selection
        compatBanner.classList.add('incompatible');
        compatIcon.textContent = '⚠️';
        compatStatus.textContent = 'Mode selection required';
        compatDesc.textContent = `${figmaInfo.name} supports ${figmaInfo.maxModes} mode${figmaInfo.maxModes > 1 ? 's' : ''}, but source has up to ${sourceInfo.maxModes}. Select which modes to import after proceeding.`;
      }
    }
    
    // Check and display plan mismatch warning
    function checkPlanMismatch() {
      const mismatchWarning = document.getElementById('plan-mismatch-warning');
      const mismatchDesc = document.getElementById('plan-mismatch-desc');
      const mismatchNote = document.getElementById('plan-mismatch-note');
      
      if (!mismatchWarning || !parsedImportCollections || parsedImportCollections.length === 0) {
        if (mismatchWarning) mismatchWarning.classList.add('hidden');
        return;
      }
      
      const sourcePlan = detectSourceJsonPlan();
      const targetPlanInfo = PLAN_LIMITS[selectedPlan];
      const sourcePlanInfo = PLAN_LIMITS[sourcePlan];
      
      // Find collections that exceed target plan limit
      const exceedingCollections = getCollectionsExceedingLimit();
      
      if (exceedingCollections.length > 0) {
        const collectionNames = exceedingCollections.map(c => c.name).join(', ');
        mismatchDesc.innerHTML = `Source JSON (${sourcePlanInfo.name}) has collections with more modes than target file (${targetPlanInfo.name}, max ${targetPlanInfo.maxModes}).`;
        mismatchNote.innerHTML = `<strong>Affected:</strong> ${collectionNames}<br>💡 Select which modes to import below, or uncheck these collections.`;
        mismatchWarning.classList.remove('hidden');
      } else {
        mismatchWarning.classList.add('hidden');
      }
    }
    
    // Get list of collections exceeding current plan's mode limit
    function getCollectionsExceedingLimit() {
      if (!parsedImportCollections) return [];
      
      const targetPlanInfo = PLAN_LIMITS[selectedPlan];
      const exceeding = [];
      
      parsedImportCollections.forEach(colObj => {
        const colName = Object.keys(colObj)[0];
        
        // Skip if collection is not selected for import
        if (!selectedImportCollections.has(colName)) return;
        
        const col = colObj[colName];
        const modes = Object.keys(col.modes || {});
        
        if (modes.length > targetPlanInfo.maxModes) {
          exceeding.push({
            name: colName,
            modesCount: modes.length,
            modes: modes,
            limit: targetPlanInfo.maxModes
          });
        }
      });
      
      return exceeding;
    }

    // Internal async validation function
    async function validateImportAsync() {
      if (!importData) return;
      
      try {
        // Use async stringify for large data
        const dataString = await stringifyJSONAsync(importData);
        
        parent.postMessage({
          pluginMessage: {
            type: 'validate_import',
            data: dataString,
            plan: selectedPlan
          }
        }, '*');
        
        // Also compute import diff preview
        parent.postMessage({
          pluginMessage: {
            type: 'compute_import_diff',
            data: dataString
          }
        }, '*');
      } catch (err) {
        console.error('Validation stringify error:', err);
        addLog('⚠️ Error preparing data for validation', 'error', 'import');
      }
    }
    
    // Throttled version to prevent excessive validation calls (300ms)
    const throttledValidateImport = throttle(() => {
      validateImportAsync();
    }, 300);

    // Public validateImport function - uses throttling
    function validateImport() {
      throttledValidateImport();
    }

    // Handle library availability check result
    function handleLibraryCheckResult(result) {
      libraryStatus = result;
      // Update both pre-proceed and post-proceed library status sections
      const sectionPre = document.getElementById('library-status-section-pre');
      const cardPre = document.getElementById('library-status-card-pre');
      const sectionPost = document.getElementById('library-status-section');
      const cardPost = document.getElementById('library-status-card');
      const importBtn = document.getElementById('import-btn');
      
      const { requiredCollections, availableCollections, missingCollections, allAvailable } = result;
      const varCount = lastValidation?.libraryDependencies?.variableCount || 0;
      
      let html = '';
      let cardClass = '';
      
      if (allAvailable) {
        // All libraries connected - can restore links
        cardClass = 'library-available';
        html = `
          <div class="library-status-header">
            <span class="library-status-icon">📚</span>
            <span class="library-status-title">Asset Sources Detected!</span>
          </div>
          <div class="library-status-message">
            ${varCount} variables reference team library collections that are <strong>connected to this file</strong>.
            Library links will be restored during import.
          </div>
          <div class="library-collection-list">
            ${availableCollections.map(col => `
              <div class="library-collection-item available">
                <span class="status-icon">✅</span>
                <span>${col}</span>
              </div>
            `).join('')}
          </div>
        `;
        importWithLibraryLinks = true;
        importBtn.textContent = '📥 Import Selected';
        addLog(`📚 Library check: All ${availableCollections.length} required library collection(s) available`, 'success', 'import');
      } else if (availableCollections.length > 0) {
        // Partial - some libraries connected
        cardClass = 'library-partial';
        html = `
          <div class="library-status-header">
            <span class="library-status-icon">⚠️</span>
            <span class="library-status-title">Partial Asset Sources</span>
          </div>
          <div class="library-status-message">
            ${varCount} variables reference team library collections. Some libraries are connected, but others are missing.
          </div>
          <div class="library-collection-list">
            ${availableCollections.map(col => `
              <div class="library-collection-item available">
                <span class="status-icon">✅</span>
                <span>${col} (connected)</span>
              </div>
            `).join('')}
            ${missingCollections.map(col => `
              <div class="library-collection-item missing">
                <span class="status-icon">❌</span>
                <span>${col} (not connected - will use fallback values)</span>
              </div>
            `).join('')}
          </div>
          <div class="library-import-options">
            <p style="font-size: 10px; margin-bottom: 6px; color: #6D4C00;"><strong>Import will:</strong></p>
            <ul style="font-size: 10px; margin: 0; padding-left: 16px; color: #6D4C00;">
              <li>Restore library links for connected libraries</li>
              <li>Use fallback values for missing libraries</li>
            </ul>
          </div>
        `;
        importWithLibraryLinks = true;
        importBtn.textContent = '📥 Import Selected';
        addLog(`⚠️ Library check: ${availableCollections.length} connected, ${missingCollections.length} missing`, 'warning', 'import');
      } else {
        // No libraries connected - will use fallback values
        cardClass = 'library-missing';
        html = `
          <div class="library-status-header">
            <span class="library-status-icon">📦</span>
            <span class="library-status-title">Asset Sources Not Connected</span>
          </div>
          <div class="library-status-message">
            ${varCount} variables reference team library collections that are <strong>not connected</strong> to this file.
            Variables will be imported with their <strong>fallback resolved values</strong>.
          </div>
          <div class="library-collection-list">
            ${missingCollections.map(col => `
              <div class="library-collection-item missing">
                <span class="status-icon">❌</span>
                <span>${col}</span>
              </div>
            `).join('')}
          </div>
          <div class="library-import-options">
            <p style="font-size: 10px; margin-bottom: 8px; color: #BF360C;">
              <strong>💡 Tip:</strong> To restore library links, go to <em>Assets panel → Team Library</em> and enable the required libraries, then re-paste the JSON.
            </p>
          </div>
        `;
        importWithLibraryLinks = false;
        importBtn.textContent = '📥 Import Selected';
        addLog(`📦 Library check: ${missingCollections.length} library collection(s) not connected - will use fallback values`, 'warning', 'import');
      }
      
      // Update pre-proceed section
      if (cardPre) {
        cardPre.className = 'library-status-card ' + cardClass;
        cardPre.innerHTML = html;
      }
      if (sectionPre) sectionPre.classList.remove('hidden');
      
      // Update post-proceed section
      if (cardPost) {
        cardPost.className = 'library-status-card ' + cardClass;
        cardPost.innerHTML = html;
      }
      if (sectionPost) sectionPost.classList.remove('hidden');
    }

    // Display import diff preview
    function displayImportDiff(diff) {
      const section = document.getElementById('import-diff-section');
      if (!section) return;
      
      if (diff.error) {
        addLog(`⚠️ Could not compute diff: ${diff.error}`, 'warning', 'import');
        section.classList.add('hidden');
        lastImportDiff = null;
        return;
      }
      
      // Store diff data for selection-aware updates
      lastImportDiff = diff;
      
      const { summary, newCollections, modifiedCollections, newVariables, modifiedVariables, newStyles, modifiedStyles } = diff;
      
      // Update summary counts in accordion header
      const totalNew = summary.variablesNew + summary.stylesNew + summary.collectionsNew;
      const totalMod = summary.variablesModified + summary.stylesModified;
      
      // Update summary counts inside accordion
      document.getElementById('diff-new-count').textContent = summary.variablesNew + summary.stylesNew + summary.collectionsNew;
      document.getElementById('diff-modified-count').textContent = summary.variablesModified + summary.stylesModified;
      document.getElementById('diff-unchanged-count').textContent = summary.variablesUnchanged;
      
      // Update breakdown counts based on selection (initial - all selected)
      updateReviewChangesCounts();
      
      section.classList.remove('hidden');
      
      // Auto-select import behavior based on diff:
      // - If there's overlap (modified or unchanged items), use Smart Merge
      // - If everything is new (no overlap with Figma), use Clean Import
      const hasOverlap = (summary.variablesModified > 0 || summary.variablesUnchanged > 0 || 
                          summary.stylesModified > 0 || modifiedCollections.length > 0);
      const smartMergeRadio = document.querySelector('input[name="import-behavior"][value="smart-merge"]');
      const cleanImportRadio = document.querySelector('input[name="import-behavior"][value="clean-import"]');
      
      if (hasOverlap) {
        // Existing items in Figma match JSON - Smart Merge makes sense
        if (smartMergeRadio) smartMergeRadio.checked = true;
      } else {
        // Everything is new, no overlap - Clean Import is recommended
        if (cleanImportRadio) cleanImportRadio.checked = true;
      }
      
      // Log summary (using already calculated values)
      addLog(`📊 Diff: ${totalNew} new, ${totalMod} modified, ${summary.variablesUnchanged} unchanged`, 'info', 'import');
    }
    
    // Update Review Changes counts based on current selection
    function updateReviewChangesCounts() {
      if (!lastImportDiff) return;
      
      const { newCollections, modifiedCollections, newVariables, modifiedVariables, newStyles, modifiedStyles } = lastImportDiff;
      
      // Filter by selected collections
      const selectedNewCollections = newCollections.filter(c => selectedImportCollections.has(c));
      const selectedModCollections = modifiedCollections.filter(c => selectedImportCollections.has(c));
      
      // Calculate variable and mode counts from parsedImportCollections based on selection
      let newVariablesCount = 0;
      let modVariablesCount = 0;
      let newModesCount = 0;
      let modModesCount = 0;
      
      // Get existing collection names from Figma
      const existingCollectionNames = new Set(collections.map(c => c.name));
      
      if (parsedImportCollections && parsedImportCollections.length > 0) {
        parsedImportCollections.forEach(colObj => {
          const colName = Object.keys(colObj)[0];
          if (!selectedImportCollections.has(colName)) return;
          
          const col = colObj[colName];
          const allModes = Object.keys(col.modes || {});
          
          // Get the modes to count - use selectedModes if available, else all modes
          const modesToCount = selectedModes[colName] 
            ? allModes.filter(m => selectedModes[colName].has(m))
            : allModes;
          
          // Count variables in this collection (using flattenObject like in updateImportPreviewStats)
          let varCount = 0;
          modesToCount.forEach(mode => {
            const modeVars = col.modes[mode];
            if (modeVars) {
              const flatVars = flattenObject(modeVars);
              varCount = Math.max(varCount, flatVars.length);
            }
          });
          
          // Check if collection is new or existing
          const isNewCollection = !existingCollectionNames.has(colName);
          
          if (isNewCollection) {
            // New collection - all variables and modes are new
            newVariablesCount += varCount;
            newModesCount += modesToCount.length;
          } else {
            // Existing collection - check variables from diff
            const colNewVars = newVariables.filter(v => v.collection === colName);
            const colModVars = modifiedVariables.filter(v => v.collection === colName);
            newVariablesCount += colNewVars.length;
            modVariablesCount += colModVars.length;
            
            // Check each selected mode
            const existingCol = collections.find(c => c.name === colName);
            const existingModeNames = existingCol ? existingCol.modes.map(m => m.name) : [];
            
            modesToCount.forEach(modeName => {
              if (!existingModeNames.includes(modeName)) {
                newModesCount++;
              } else if (colModVars.length > 0) {
                // Mode exists and has modified variables
                modModesCount++;
              }
            });
          }
        });
      }
      
      // Filter styles by selected style types
      let selectedNewStyles = 0;
      let selectedModStyles = 0;
      
      const colorStylesCheck = document.getElementById('import-color-styles-sel');
      const textStylesCheck = document.getElementById('import-text-styles-sel');
      const effectStylesCheck = document.getElementById('import-effect-styles-sel');
      const gridStylesCheck = document.getElementById('import-grid-styles-sel');
      
      newStyles.forEach(s => {
        if (s.type === 'color' && colorStylesCheck?.checked) selectedNewStyles++;
        else if (s.type === 'text' && textStylesCheck?.checked) selectedNewStyles++;
        else if (s.type === 'effect' && effectStylesCheck?.checked) selectedNewStyles++;
        else if (s.type === 'grid' && gridStylesCheck?.checked) selectedNewStyles++;
      });
      
      modifiedStyles.forEach(s => {
        if (s.type === 'color' && colorStylesCheck?.checked) selectedModStyles++;
        else if (s.type === 'text' && textStylesCheck?.checked) selectedModStyles++;
        else if (s.type === 'effect' && effectStylesCheck?.checked) selectedModStyles++;
        else if (s.type === 'grid' && gridStylesCheck?.checked) selectedModStyles++;
      });
      
      // Update the counts in the UI
      const collectionsCounts = document.getElementById('diff-collections-counts');
      const modesCounts = document.getElementById('diff-modes-counts');
      const variablesCounts = document.getElementById('diff-variables-counts');
      const stylesCounts = document.getElementById('diff-styles-counts');
      
      if (collectionsCounts) {
        collectionsCounts.textContent = `(➕${selectedNewCollections.length} 📝${selectedModCollections.length})`;
      }
      if (modesCounts) {
        modesCounts.textContent = `(➕${newModesCount} 📝${modModesCount})`;
      }
      if (variablesCounts) {
        variablesCounts.textContent = `(➕${newVariablesCount} 📝${modVariablesCount})`;
      }
      if (stylesCounts) {
        stylesCounts.textContent = `(➕${selectedNewStyles} 📝${selectedModStyles})`;
      }
      
      // Update summary counts
      const totalNew = selectedNewCollections.length + newVariablesCount + selectedNewStyles;
      const totalMod = modVariablesCount + selectedModStyles;
      
      const newCountEl = document.getElementById('diff-new-count');
      const modCountEl = document.getElementById('diff-modified-count');
      
      if (newCountEl) newCountEl.textContent = totalNew;
      if (modCountEl) modCountEl.textContent = totalMod;
    }
    
    // Handle Import Preview accordion toggle
    function onImportPreviewToggle(details) {
      if (details && details.open) {
        importPreviewReviewed = true;
        // Now user has reviewed the preview, enable the import button
        updateImportButtonState();
        addLog('👀 Import preview reviewed', 'info', 'import');
      } else {
        // Accordion collapsed - disable import button
        importPreviewReviewed = false;
        updateImportButtonState();
      }
    }

    // Handle font availability check result
    function handleFontCheckResult(result) {
      fontStatus = result;
      // Update both pre-proceed and post-proceed font status sections
      const sectionPre = document.getElementById('font-status-section-pre');
      const cardPre = document.getElementById('font-status-card-pre');
      const sectionPost = document.getElementById('font-status-section');
      const cardPost = document.getElementById('font-status-card');
      
      const { requiredFonts, availableFonts, missingFonts, allAvailable } = result;
      const styleCount = lastValidation?.fontDependencies?.styleCount || 0;
      
      let html = '';
      let cardClass = '';
      
      if (allAvailable) {
        // All fonts available
        cardClass = 'font-available';
        html = `
          <div class="font-status-header">
            <span class="font-status-icon">🔤</span>
            <span class="font-status-title">All Fonts Available</span>
          </div>
          <div class="font-status-message">
            All ${requiredFonts.length} font(s) used by ${styleCount} text style(s) are installed and ready for import.
          </div>
          <div class="font-list">
            ${availableFonts.map(f => `
              <div class="font-item available">
                <span class="status-icon">✅</span>
                <span>${f.family} ${f.style}</span>
              </div>
            `).join('')}
          </div>
        `;
        addLog(`🔤 Font check: All ${availableFonts.length} required font(s) available`, 'success', 'import');
      } else if (availableFonts.length > 0) {
        // Partial - some fonts available
        cardClass = 'font-partial';
        html = `
          <div class="font-status-header">
            <span class="font-status-icon">⚠️</span>
            <span class="font-status-title">Some Fonts Missing</span>
          </div>
          <div class="font-status-message">
            ${styleCount} text style(s) require ${requiredFonts.length} font(s). Some are available, but ${missingFonts.length} are missing.
            Text styles with missing fonts may not import correctly.
          </div>
          <div class="font-list">
            ${availableFonts.map(f => `
              <div class="font-item available">
                <span class="status-icon">✅</span>
                <span>${f.family} ${f.style}</span>
              </div>
            `).join('')}
            ${missingFonts.map(f => `
              <div class="font-item missing">
                <span class="status-icon">❌</span>
                <span>${f.family} ${f.style}</span>
              </div>
            `).join('')}
          </div>
          <div class="font-tip">
            💡 <strong>Tip:</strong> Install missing fonts from your system or a font provider (e.g., Google Fonts, Adobe Fonts) before importing.
          </div>
        `;
        addLog(`⚠️ Font check: ${availableFonts.length} available, ${missingFonts.length} missing`, 'warning', 'import');
      } else {
        // No fonts available
        cardClass = 'font-missing';
        html = `
          <div class="font-status-header">
            <span class="font-status-icon">❌</span>
            <span class="font-status-title">Fonts Not Found</span>
          </div>
          <div class="font-status-message">
            ${styleCount} text style(s) require ${requiredFonts.length} font(s) that are <strong>not installed</strong>.
            Text styles may fail to import or appear incorrectly.
          </div>
          <div class="font-list">
            ${missingFonts.map(f => `
              <div class="font-item missing">
                <span class="status-icon">❌</span>
                <span>${f.family} ${f.style}</span>
              </div>
            `).join('')}
          </div>
          <div class="font-tip">
            💡 <strong>Install these fonts first:</strong> Download from Google Fonts, Adobe Fonts, or other providers, install on your system, then restart Figma and re-paste the JSON.
          </div>
        `;
        addLog(`❌ Font check: ${missingFonts.length} required font(s) not installed`, 'error', 'import');
      }
      
      // Update pre-proceed section
      if (cardPre) {
        cardPre.className = 'font-status-card ' + cardClass;
        cardPre.innerHTML = html;
      }
      if (sectionPre) sectionPre.classList.remove('hidden');
      
      // Update post-proceed section
      if (cardPost) {
        cardPost.className = 'font-status-card ' + cardClass;
        cardPost.innerHTML = html;
      }
      if (sectionPost) sectionPost.classList.remove('hidden');
    }

    function displayValidationResult(validation) {
      lastValidation = validation;
      const resultsEl = document.getElementById('validation-results');
      const modeSelectionContainer = document.getElementById('mode-selection-container');
      const importBtn = document.getElementById('import-btn');
      const statusEl = document.getElementById('import-status');
      const validationEmpty = document.getElementById('import-validation-empty');
      
      // Hide empty state since we have validation results
      if (validationEmpty) validationEmpty.classList.add('hidden');
      
      let html = '';
      const planInfo = PLAN_LIMITS[selectedPlan];
      
      // Check using our local function that respects collection selection
      const exceedingCollections = getCollectionsExceedingLimit();
      const needsModeSelection = exceedingCollections.length > 0 && selectedPlan !== 'enterprise';
      
      // Show mode selection UI if needed (instead of blocking)
      if (needsModeSelection) {
        // Mode selection UI is shown via checkPlanMismatch and renderModeSelection
        renderModeSelection(validation);
        
        // Enable import if modes are selected within limits
        updateImportButtonState();
      } else {
        // Hide mode selection if not needed
        modeSelectionContainer.classList.add('hidden');
        
        // Show warnings
        if (validation.warnings && validation.warnings.length > 0) {
          html += `
            <div class="validation-alert warning">
              <div class="validation-alert-title">⚠️ Warnings</div>
              <ul>${validation.warnings.map(w => `<li>${w}</li>`).join('')}</ul>
            </div>
          `;
        }
        
        // Show success if no errors
        if (validation.canImport) {
          html += `
            <div class="validation-alert success">
              <div class="validation-alert-title">✅ Ready to Import</div>
              <p>Import is compatible with ${planInfo.name} plan (${planInfo.maxModes === Infinity ? 'unlimited' : planInfo.maxModes} modes/collection)</p>
              ${validation.importing ? `
                <p style="margin-top: 4px; font-size: 10px;">
                  ${validation.importing.collections} collections • 
                  ${validation.importing.totalVariables} variables • 
                  Max ${validation.importing.maxModesInAnyCollection} modes in any collection
                </p>
              ` : ''}
            </div>
          `;
          // Use unified button state handler to respect importPreviewReviewed flag
          updateImportButtonState();
        }
      }
      
      resultsEl.innerHTML = html;
    }
    
    // Render mode selection UI for collections exceeding limits
    function renderModeSelection(validation) {
      const container = document.getElementById('mode-selection-container');
      const planInfo = PLAN_LIMITS[selectedPlan];
      const maxModes = planInfo.maxModes;
      
      // Get collections that are selected AND exceed limit
      const exceedingCollections = getCollectionsExceedingLimit();
      
      if (exceedingCollections.length === 0) {
        container.classList.add('hidden');
        return;
      }
      
      let collectionsHtml = '';
      
      // Only show mode selection for collections that exceed limit AND are selected
      for (const exceedingCol of exceedingCollections) {
        const colName = exceedingCol.name;
        const modes = exceedingCol.modes;
        
        collectionModes[colName] = modes;
        
        // Initialize selected modes if not already set
        if (!selectedModes[colName]) {
          // Pre-select first N modes up to limit
          selectedModes[colName] = new Set(modes.slice(0, maxModes));
        }
        
        const selectedCount = selectedModes[colName].size;
        const isWithinLimit = selectedCount <= maxModes;
        const countClass = isWithinLimit ? 'valid' : 'exceeded';
        
        collectionsHtml += `
          <div class="collection-mode-selector collection-exceeds-limit">
            <div class="collection-mode-header">
              <span class="collection-mode-name">📁 ${colName}</span>
              <span class="collection-mode-count ${countClass}">
                ${selectedCount}/${maxModes} selected (${modes.length} in source)
              </span>
            </div>
            <div class="mode-checkboxes" data-collection="${colName}">
              ${modes.map(mode => {
                const isSelected = selectedModes[colName].has(mode);
                const canSelect = isSelected || selectedCount < maxModes;
                return `
                  <label class="mode-checkbox-label ${isSelected ? 'selected' : ''} ${!canSelect ? 'disabled' : ''}"
                         onclick="toggleMode('${colName}', '${mode}', event)">
                    <input type="checkbox" ${isSelected ? 'checked' : ''} ${!canSelect ? 'disabled' : ''}>
                    <span>${mode}</span>
                  </label>
                `;
              }).join('')}
            </div>
          </div>
        `;
      }
      
      const html = `
        <div class="mode-selection-section">
          <div class="mode-selection-header">
            <div class="mode-selection-title">
              <span>🎛️</span> Select Modes to Import
            </div>
            <p class="mode-selection-help">
              Target file (${planInfo.name}) allows up to ${maxModes} mode${maxModes === 1 ? '' : 's'} per collection. 
              Select which modes you want to import for each affected collection.
            </p>
          </div>
          <div class="mode-selection-scroll-wrapper" style="position: relative;">
            <div class="mode-selection-fade-top" id="mode-selection-fade-top"></div>
            <div class="mode-selection-fade-bottom" id="mode-selection-fade-bottom"></div>
            <div class="mode-selection-scroll-container" id="mode-selection-scroll">
              ${collectionsHtml}
            </div>
          </div>
        </div>
      `;
      
      container.innerHTML = html;
      container.classList.remove('hidden');
      
      // Initialize scroll fade for mode selection
      initModeSelectionScrollFade();
    }
    
    // Initialize scroll fade indicators for mode selection
    function initModeSelectionScrollFade() {
      const scrollContainer = document.getElementById('mode-selection-scroll');
      const fadeTop = document.getElementById('mode-selection-fade-top');
      const fadeBottom = document.getElementById('mode-selection-fade-bottom');
      
      if (!scrollContainer || !fadeTop || !fadeBottom) return;
      
      function updateScrollFade() {
        const scrollHeight = scrollContainer.scrollHeight;
        const clientHeight = scrollContainer.clientHeight;
        const scrollTop = scrollContainer.scrollTop;
        const isScrollable = scrollHeight > clientHeight;
        
        // Show top fade when scrolled down
        if (scrollTop > 5) {
          fadeTop.classList.add('visible');
        } else {
          fadeTop.classList.remove('visible');
        }
        
        // Show bottom fade when not at bottom
        if (isScrollable && (scrollTop + clientHeight < scrollHeight - 5)) {
          fadeBottom.classList.add('visible');
        } else {
          fadeBottom.classList.remove('visible');
        }
      }
      
      scrollContainer.addEventListener('scroll', updateScrollFade, { passive: true });
      // Initial check
      setTimeout(updateScrollFade, 50);
    }
    
    // Toggle mode selection
    function toggleMode(collectionName, modeName, event) {
      event.preventDefault();
      event.stopPropagation();
      
      const planInfo = PLAN_LIMITS[selectedPlan];
      const maxModes = planInfo.maxModes;
      
      if (!selectedModes[collectionName]) {
        selectedModes[collectionName] = new Set();
      }
      
      const modeSet = selectedModes[collectionName];
      
      if (modeSet.has(modeName)) {
        // Always allow deselection (but must have at least 1)
        if (modeSet.size > 1) {
          modeSet.delete(modeName);
        }
      } else {
        // Only allow selection if under limit
        if (modeSet.size < maxModes) {
          modeSet.add(modeName);
        }
      }
      
      // Instead of full re-render, do targeted DOM updates to preserve scroll
      const selectedCount = modeSet.size;
      const isWithinLimit = selectedCount <= maxModes;
      
      // Find the mode checkboxes container for this collection
      const modeCheckboxesContainer = document.querySelector(`.mode-checkboxes[data-collection="${collectionName}"]`);
      if (modeCheckboxesContainer) {
        // Update each checkbox label
        const labels = modeCheckboxesContainer.querySelectorAll('.mode-checkbox-label');
        labels.forEach(label => {
          const checkbox = label.querySelector('input[type="checkbox"]');
          const modeNameSpan = label.querySelector('span');
          const labelModeName = modeNameSpan ? modeNameSpan.textContent : '';
          
          const isSelected = modeSet.has(labelModeName);
          const canSelect = isSelected || selectedCount < maxModes;
          
          // Update checkbox state
          checkbox.checked = isSelected;
          checkbox.disabled = !canSelect;
          
          // Update label classes
          label.classList.toggle('selected', isSelected);
          label.classList.toggle('disabled', !canSelect);
        });
        
        // Update the count display
        const selector = modeCheckboxesContainer.closest('.collection-mode-selector');
        if (selector) {
          const countEl = selector.querySelector('.collection-mode-count');
          if (countEl) {
            const modes = collectionModes[collectionName] || [];
            countEl.textContent = `${selectedCount}/${maxModes} selected (${modes.length} in source)`;
            countEl.classList.toggle('valid', isWithinLimit);
            countEl.classList.toggle('exceeded', !isWithinLimit);
          }
        }
      }
      
      updateModeSelectionState();
    }
    
    // Update mode selection validation state (called from mode checkboxes)
    function updateModeSelectionState() {
      const statusEl = document.getElementById('import-status');
      const planInfo = PLAN_LIMITS[selectedPlan];
      
      let allValid = true;
      let totalSelectedModes = 0;
      
      for (const colName in selectedModes) {
        const count = selectedModes[colName].size;
        totalSelectedModes += count;
        if (count === 0 || count > planInfo.maxModes) {
          allValid = false;
        }
      }
      
      // Only update status text for mode-related info, don't enable button here
      // The main updateImportButtonState handles button enable/disable with review check
      if (!allValid && statusEl) {
        statusEl.textContent = 'Select modes within your plan limit to continue';
      }
      
      // Call the main button state function which checks importPreviewReviewed
      updateImportButtonState();
      
      // Update Review Changes counts to reflect selected modes
      updateReviewChangesCounts();
    }

    // Tab switching for new 4-column layout
    document.querySelectorAll('.tab-btn').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab-btn').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(tab.dataset.tab + '-panel').classList.add('active');
      });
    });

    // User Mode Toggle (Simple/Advanced)
    let currentUserMode = 'simple';
    document.querySelectorAll('input[name="user-mode"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        currentUserMode = e.target.value;
        if (currentUserMode === 'advanced') {
          document.body.classList.add('advanced-mode');
          // Show library refs option if deps detected
          const exportLibraryOption = document.getElementById('export-library-option');
          if (exportLibraryOption && window.detectedLibraryDeps?.length > 0) {
            exportLibraryOption.classList.remove('hidden');
          }
        } else {
          document.body.classList.remove('advanced-mode');
          // Hide library refs option in simple mode
          const exportLibraryOption = document.getElementById('export-library-option');
          if (exportLibraryOption) {
            exportLibraryOption.classList.add('hidden');
          }
        }
        // Re-render import collections if on selection face
        const selectionFace = document.getElementById('import-selection-face');
        if (selectionFace && selectionFace.style.display !== 'none') {
          renderImportCollectionsList();
        }
      });
    });

    // Get current user mode
    function isAdvancedMode() {
      return currentUserMode === 'advanced';
    }
    
    // Show/hide custom merge options based on selected behavior
    function updateCustomMergeVisibility() {
      const customMergeOptions = document.getElementById('custom-merge-options');
      const selectedBehavior = document.querySelector('input[name="import-behavior"]:checked')?.value;
      
      if (customMergeOptions) {
        customMergeOptions.style.display = selectedBehavior === 'custom-merge' ? 'block' : 'none';
      }
    }
    
    // Get custom merge options (which types to clear)
    function getCustomMergeOptions() {
      return {
        clearVariables: document.getElementById('custom-clear-variables')?.checked || false,
        clearStyles: document.getElementById('custom-clear-styles')?.checked || false
      };
    }

    // Get import behavior (smart-merge, clean-import, or custom-merge)
    // In Simple mode: use Clean Import if no overlap with existing data, Smart Merge if there's overlap
    // In Advanced mode: respect the user's radio selection
    function getImportBehavior() {
      if (!isAdvancedMode()) {
        // In Simple mode, auto-determine based on diff data
        // If there's no overlap (all new items), use Clean Import
        // If there's overlap (modified/unchanged items), use Smart Merge
        if (lastImportDiff) {
          const { summary, modifiedCollections } = lastImportDiff;
          const hasOverlap = (summary.variablesModified > 0 || summary.variablesUnchanged > 0 || 
                              summary.stylesModified > 0 || modifiedCollections.length > 0);
          return hasOverlap ? 'smart-merge' : 'clean-import';
        }
        return 'clean-import'; // Default to clean import if no diff data available
      }
      const selected = document.querySelector('input[name="import-behavior"]:checked');
      return selected ? selected.value : 'smart-merge';
    }

    // Store per-collection behavior (Advanced mode)
    const collectionBehaviors = new Map();

    // Set collection behavior
    function setCollectionBehavior(collectionName, behavior) {
      collectionBehaviors.set(collectionName, behavior);
    }

    // Get collection behavior
    function getCollectionBehavior(collectionName) {
      return collectionBehaviors.get(collectionName) || 'merge';
    }

    // Message handling
    window.onmessage = function(event) {
      const msg = event.data.pluginMessage;
      if (!msg) return;

      switch (msg.type) {
        case 'log':
          addLog(msg.message);
          break;
        case 'collections':
          collections = msg.data.collections;
          stylesInfo = msg.data.styles || { colorStyles: 0, textStyles: 0, effectStyles: 0, gridStyles: 0 };
          renderExportCollections();
          updateStyleCheckboxLabels();
          
          // Show asset source info in Status Check
          const structureStats = msg.data.stats || {};
          const assetSourceBanner = document.getElementById('asset-source-banner');
          const assetSourceList = document.getElementById('asset-source-list');
          if (assetSourceBanner && assetSourceList) {
            let sourceHtml = '';
            // Variables info
            if (structureStats.totalVariables > 0) {
              sourceHtml += `<span class="alert-item" style="border-color: #4CAF50;">✅ ${structureStats.totalVariables} Local Variables</span>`;
            }
            if (structureStats.libraryAliases > 0) {
              sourceHtml += `<span class="alert-item" style="border-color: #FAAD14;">📚 ${structureStats.libraryAliases} Library References</span>`;
            }
            // Styles info
            const totalStyles = (stylesInfo.colorStyles || 0) + (stylesInfo.textStyles || 0) + (stylesInfo.effectStyles || 0) + (stylesInfo.gridStyles || 0);
            if (totalStyles > 0) {
              sourceHtml += `<span class="alert-item" style="border-color: #4CAF50;">✅ ${totalStyles} Local Styles</span>`;
            }
            if (sourceHtml) {
              assetSourceBanner.classList.remove('hidden');
              assetSourceList.innerHTML = sourceHtml;
            } else {
              assetSourceBanner.classList.add('hidden');
            }
          }
          
          // Show bindings info in Status Check
          const bindingsInfoBanner = document.getElementById('bindings-info-banner');
          const bindingsInfoList = document.getElementById('bindings-info-list');
          if (bindingsInfoBanner && bindingsInfoList) {
            let bindingsHtml = '';
            if (structureStats.totalAliases > 0) {
              bindingsHtml += `<span class="alert-item">🔗 ${structureStats.totalAliases} Variable Aliases</span>`;
              if (structureStats.localAliases > 0) {
                bindingsHtml += `<span class="alert-item" style="border-color: #4CAF50;">✅ ${structureStats.localAliases} Local</span>`;
              }
            }
            if (structureStats.styleBindings > 0) {
              bindingsHtml += `<span class="alert-item">🎨 ${structureStats.styleBindings} Styles → Variables</span>`;
            }
            if (bindingsHtml) {
              bindingsInfoBanner.classList.remove('hidden');
              bindingsInfoList.innerHTML = bindingsHtml;
            } else {
              bindingsInfoBanner.classList.add('hidden');
            }
          }
          
          // Show fonts used in Status Check
          const fontsUsed = msg.data.fontsUsed || [];
          const fontsUsedBanner = document.getElementById('fonts-used-banner');
          const fontsUsedList = document.getElementById('fonts-used-list');
          if (fontsUsedBanner && fontsUsedList) {
            if (fontsUsed.length > 0) {
              fontsUsedBanner.classList.remove('hidden');
              fontsUsedList.innerHTML = fontsUsed.map(f => 
                `<span class="alert-item">🔤 ${f.family} (${f.styles.join(', ')})</span>`
              ).join('');
            } else {
              fontsUsedBanner.classList.add('hidden');
            }
          }
          
          // Handle library dependencies warning in Status Check
          const libraryDeps = msg.data.libraryDependencies || [];
          const warningBanner = document.getElementById('library-warning-banner');
          const depsList = document.getElementById('library-deps-list');
          const exportLibraryOption = document.getElementById('export-library-option');
          
          // Store library deps globally for export
          window.detectedLibraryDeps = libraryDeps;
          
          if (libraryDeps.length > 0) {
            warningBanner.classList.remove('hidden');
            depsList.innerHTML = libraryDeps.map(name => `<span class="alert-item">📚 ${name}</span>`).join('');
            addLog(`📚 Detected library dependencies: ${libraryDeps.join(', ')}`, 'warning');
            
            // Show the export library option checkbox (only in Advanced mode)
            if (exportLibraryOption && isAdvancedMode()) {
              exportLibraryOption.classList.remove('hidden');
            }
          } else {
            warningBanner.classList.add('hidden');
            // Hide the export library option checkbox
            if (exportLibraryOption) {
              exportLibraryOption.classList.add('hidden');
            }
          }
          
          // Update the library warning note based on checkbox state
          updateLibraryWarningNote();
          
          // Calculate and show plan compatibility in Status Check
          const planCompatBanner = document.getElementById('plan-compatibility-banner');
          const planCompatList = document.getElementById('plan-compatibility-list');
          const maxModesDetected = document.getElementById('max-modes-detected');
          if (planCompatBanner && planCompatList && collections.length > 0) {
            // Find the maximum modes in any collection
            let maxModes = 0;
            collections.forEach(c => {
              if (c.modes && c.modes.length > maxModes) {
                maxModes = c.modes.length;
              }
            });
            
            // Determine compatible plans
            let planHtml = '';
            const plans = [
              { key: 'starter', name: 'Starter', max: 1, icon: '🆓' },
              { key: 'professional', name: 'Professional', max: 10, icon: '💼' },
              { key: 'organization', name: 'Organization', max: 20, icon: '🏢' },
              { key: 'enterprise', name: 'Enterprise', max: Infinity, icon: '🚀' }
            ];
            
            plans.forEach(plan => {
              const isCompatible = maxModes <= plan.max;
              const borderColor = isCompatible ? '#4CAF50' : '#FF4D4F';
              const statusIcon = isCompatible ? '✅' : '❌';
              const modesText = plan.max === Infinity ? '∞' : plan.max;
              planHtml += `<span class="alert-item" style="border-color: ${borderColor};">${statusIcon} ${plan.icon} ${plan.name} (${modesText})</span>`;
            });
            
            planCompatBanner.classList.remove('hidden');
            planCompatList.innerHTML = planHtml;
            maxModesDetected.textContent = maxModes;
          } else if (planCompatBanner) {
            planCompatBanner.classList.add('hidden');
          }
          
          updateStatusCheckVisibility();
          break;

        case 'collection_details':
          updateCollectionDetails(msg.data);
          break;
        case 'export_complete':
          exportData = msg.data.data;
          document.getElementById('export-output').value = exportData;
          
          // Show JSON preview in Activity Log column
          const jsonPreviewSection = document.getElementById('export-json-preview-section');
          const jsonPreviewContent = document.getElementById('export-json-preview');
          if (jsonPreviewSection && jsonPreviewContent) {
            jsonPreviewSection.classList.remove('hidden');
            // Show truncated preview (first 2000 chars with ellipsis)
            const previewText = exportData.length > 2000 
              ? exportData.substring(0, 2000) + '\n\n... (truncated - use Copy/Download for full data)'
              : exportData;
            jsonPreviewContent.textContent = previewText;
          }
          
          const stats = msg.data.stats;
          let logMsg = `✅ Export: ${stats.collections} collections, ${stats.variables} vars`;
          if (stats.styles) {
            const styleTotal = (stats.styles.color || 0) + (stats.styles.text || 0) + (stats.styles.effect || 0) + (stats.styles.grid || 0);
            if (styleTotal > 0) {
              logMsg += `, ${styleTotal} styles`;
            }
          }
          addLog(logMsg, 'success');
          
          // Show external collections warning if present
          const extColls = msg.data.externalCollections;
          if (extColls && extColls.length > 0) {
            addLog(`📚 ${extColls.length} library collection(s) referenced but not exported: ${extColls.join(', ')}`, 'warning');
            addLog(`⚠️ Aliases to library tokens will use raw values on import`, 'warning');
          }
          
          // Show font requirements in Status Check
          const reqFonts = msg.data.requiredFonts;
          const fontBanner = document.getElementById('font-requirements-banner');
          const fontList = document.getElementById('font-requirements-list');
          if (reqFonts && reqFonts.length > 0) {
            fontBanner.classList.remove('hidden');
            fontList.innerHTML = reqFonts.map(f => 
              `<span class="alert-item">🔤 ${f.family} ${f.style}</span>`
            ).join('');
            addLog(`🔤 Required fonts for import: ${reqFonts.map(f => `${f.family} ${f.style}`).join(', ')}`, 'info');
            updateStatusCheckVisibility();
          } else {
            fontBanner.classList.add('hidden');
            updateStatusCheckVisibility();
          }
          break;
        case 'import_complete':
          const s = msg.data.stats;
          let importMsg = `✅ Import: ${s.collectionsCreated} collections, ${s.variablesCreated} vars created`;
          if (s.variablesUpdated > 0) {
            importMsg += `, ${s.variablesUpdated} vars updated`;
          }
          if (s.stylesCreated > 0 || s.stylesUpdated > 0) {
            importMsg += `, ${s.stylesCreated} styles created, ${s.stylesUpdated} updated`;
          }
          addLog(importMsg, 'success', 'import');
          loadCollections();
          document.getElementById('import-input').value = '';
          document.getElementById('file-input').value = ''; // Reset file input for re-selection
          const importBtnComplete = document.getElementById('import-btn');
          importBtnComplete.disabled = true;
          importBtnComplete.textContent = '📥 Import Selected'; // Reset button text
          document.getElementById('import-status').textContent = 'Load a JSON file to begin';
          
          // Reset import preview to empty states
          const importStatsSection = document.getElementById('import-stats-section');
          const importTreeSection = document.getElementById('import-preview-tree-section');
          const importOrderEmpty = document.getElementById('import-empty-preview-order');
          const importTreeEmpty = document.getElementById('import-empty-preview-tree');
          const importTotalHeader = document.getElementById('import-stats-total-header');
          if (importStatsSection) importStatsSection.style.display = 'none';
          if (importTreeSection) importTreeSection.classList.add('hidden');
          if (importOrderEmpty) importOrderEmpty.style.display = 'flex';
          if (importTreeEmpty) importTreeEmpty.style.display = 'flex';
          if (importTotalHeader) importTotalHeader.classList.add('hidden');
          
          // Clear the file loaded indicator after successful import
          clearFileLoadedIndicator();
          
          // Show undo section after successful import
          if (lastImportSnapshot) {
            showUndoSection();
            addLog('💡 Tip: You can undo this import using the button below', 'info', 'import');
          }
          
          // Flash the clear button to indicate where to click next
          const clearBtnFlash = document.getElementById('import-clear-btn');
          if (clearBtnFlash && !clearBtnFlash.disabled) {
            clearBtnFlash.classList.add('btn-flash-attention');
            // Remove animation class after it completes (3 cycles × 0.8s = 2.4s)
            setTimeout(() => {
              clearBtnFlash.classList.remove('btn-flash-attention');
            }, 2500);
          }
          break;
        case 'snapshot_created':
          // Snapshot created, now proceed with actual import
          lastImportSnapshot = msg.data.snapshot;
          addLog('✅ Snapshot saved, proceeding with import...', 'success', 'import');
          
          if (window._pendingImportAfterSnapshot) {
            const { data, options } = window._pendingImportAfterSnapshot;
            window._pendingImportAfterSnapshot = null;
            executeImportAfterSnapshot(data, options);
          }
          break;
        case 'snapshot_error':
          addLog('⚠️ Could not create snapshot, proceeding anyway...', 'warning', 'import');
          lastImportSnapshot = null;
          
          if (window._pendingImportAfterSnapshot) {
            const { data, options } = window._pendingImportAfterSnapshot;
            window._pendingImportAfterSnapshot = null;
            executeImportAfterSnapshot(data, options);
          }
          break;
        case 'undo_complete':
          addLog('✅ Import undone successfully! File restored to previous state.', 'success', 'import');
          hideUndoSection();
          loadCollections();
          
          // Reset undo button
          const undoBtnComplete = document.getElementById('undo-import-btn');
          if (undoBtnComplete) {
            undoBtnComplete.disabled = false;
            undoBtnComplete.innerHTML = '<span class="undo-icon">↩️</span> Undo Import';
          }
          break;
        case 'undo_error':
          addLog(`❌ Undo failed: ${msg.data.error}`, 'error', 'import');
          
          // Reset undo button
          const undoBtnError = document.getElementById('undo-import-btn');
          if (undoBtnError) {
            undoBtnError.disabled = false;
            undoBtnError.innerHTML = '<span class="undo-icon">↩️</span> Undo Import';
          }
          break;
        case 'import_rolling_back':
          // Import failed, automatic rollback in progress
          addLog(`⚠️ Import failed: ${msg.data.error}`, 'error', 'import');
          addLog('🔄 Automatic rollback in progress...', 'info', 'import');
          document.getElementById('import-status').textContent = 'Rolling back changes...';
          break;
        case 'import_rollback_complete':
          // Automatic rollback succeeded
          addLog('✅ ' + msg.data.message, 'success', 'import');
          document.getElementById('import-status').textContent = 'Import failed - file restored';
          const importBtnRollback = document.getElementById('import-btn');
          importBtnRollback.disabled = false;
          importBtnRollback.textContent = '📥 Import Selected'; // Reset button text
          loadCollections();
          break;
        case 'import_rollback_failed':
          // Automatic rollback failed
          addLog(`❌ Rollback failed: ${msg.data.rollbackError}`, 'error', 'import');
          addLog('⚠️ ' + msg.data.message, 'warning', 'import');
          document.getElementById('import-status').textContent = 'Import and rollback failed - use Cmd+Z';
          const importBtnFailed = document.getElementById('import-btn');
          importBtnFailed.disabled = false;
          importBtnFailed.textContent = '📥 Import Selected'; // Reset button text
          break;
        case 'clear_complete':
          addLog(`✅ Cleared: ${msg.data.message}`, 'success');
          loadCollections();
          break;
        case 'validation_result':
          displayValidationResult(msg.data);
          // If library dependencies detected, trigger library check
          if (msg.data.libraryDependencies && msg.data.libraryDependencies.collections && msg.data.libraryDependencies.collections.length > 0) {
            parent.postMessage({
              pluginMessage: {
                type: 'check_libraries',
                collections: msg.data.libraryDependencies.collections
              }
            }, '*');
          } else {
            // No library dependencies - hide library status (both pre and post)
            const libSection = document.getElementById('library-status-section');
            const libSectionPre = document.getElementById('library-status-section-pre');
            if (libSection) libSection.classList.add('hidden');
            if (libSectionPre) libSectionPre.classList.add('hidden');
            libraryStatus = null;
          }
          // If font dependencies detected, trigger font check
          if (msg.data.fontDependencies && msg.data.fontDependencies.fonts && msg.data.fontDependencies.fonts.length > 0) {
            parent.postMessage({
              pluginMessage: {
                type: 'check_fonts',
                fonts: msg.data.fontDependencies.fonts
              }
            }, '*');
          } else {
            // No font dependencies - hide font status (both pre and post)
            const fontSection = document.getElementById('font-status-section');
            const fontSectionPre = document.getElementById('font-status-section-pre');
            if (fontSection) fontSection.classList.add('hidden');
            if (fontSectionPre) fontSectionPre.classList.add('hidden');
            fontStatus = null;
          }
          break;
        case 'library_check_result':
          handleLibraryCheckResult(msg.data);
          break;
        case 'font_check_result':
          handleFontCheckResult(msg.data);
          break;
        case 'plan_detected':
          handlePlanDetected(msg.data);
          break;
        case 'import_diff_result':
          displayImportDiff(msg.data);
          break;
        case 'error':
          addLog('❌ ' + msg.data.message, 'error');
          break;
      }
    };

    // Maximum log entries to keep (prevents memory bloat with large operations)
    const MAX_LOG_ENTRIES = 100;
    
    // Get current active log area based on active tab
    function getActiveLogArea() {
      const exportPanel = document.getElementById('export-panel');
      if (exportPanel && exportPanel.classList.contains('active')) {
        return document.getElementById('log-area-export');
      }
      return document.getElementById('log-area-import');
    }
    
    function addLog(message, type = 'info', targetTab = null) {
      // If targetTab is specified, use that tab's log area directly
      // Otherwise, use active tab's log area
      const logArea = targetTab 
        ? document.getElementById(`log-area-${targetTab}`)
        : getActiveLogArea();
      if (!logArea) return;
      
      const time = new Date().toLocaleTimeString();
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `<span class="log-time">${time}</span><span class="log-${type}">${message}</span>`;
      
      // Use requestAnimationFrame for smooth DOM updates
      rafUpdate(() => {
        logArea.appendChild(entry);
        
        // Limit log entries to prevent memory issues with large imports
        while (logArea.children.length > MAX_LOG_ENTRIES) {
          logArea.removeChild(logArea.firstChild);
        }
        
        logArea.scrollTop = logArea.scrollHeight;
      });
    }

    // ========== EXPORT ==========
    
    // Track selected export modes per collection
    const selectedExportModes = new Map(); // collectionName -> Set of mode names

    function renderExportCollections() {
      const container = document.getElementById('export-collections');
      
      if (collections.length === 0) {
        container.innerHTML = '<div class="loading">No variable collections found</div>';
        // Check if styles also empty - if so, show empty state in preview
        const totalStyles = stylesInfo.colorStyles + stylesInfo.textStyles + stylesInfo.effectStyles + stylesInfo.gridStyles;
        if (totalStyles === 0) {
          showEmptyStructureState();
        }
        return;
      }

      container.innerHTML = collections.map(c => {
        selectedExportCollections.add(c.name); // Select all by default
        // Initialize all modes as selected for this collection
        selectedExportModes.set(c.name, new Set(c.modes));
        
        const modeCheckboxes = c.modes.length > 1 ? `
          <div class="collection-modes advanced-only-block" style="margin-top: 4px; padding-top: 4px; border-top: 1px dashed var(--color-border);">
            <div style="font-size: 9px; color: var(--color-text-secondary); margin-bottom: 3px;">Export modes:</div>
            <div style="display: flex; flex-wrap: wrap; gap: 4px;">
              ${c.modes.map(mode => `
                <label class="mode-checkbox-label" style="display: flex; align-items: center; gap: 3px; font-size: 10px; padding: 2px 6px; background: var(--color-bg); border: 1px solid var(--color-border); border-radius: 3px; cursor: pointer;">
                  <input type="checkbox" checked onclick="event.stopPropagation(); toggleExportMode('${c.name}', '${mode}', this.checked)" style="width: 12px; height: 12px;">
                  <span>${mode}</span>
                </label>
              `).join('')}
            </div>
          </div>
        ` : '';
        
        return `
          <div class="collection-item" onclick="toggleExportCollection('${c.name}')">
            <input type="checkbox" class="collection-checkbox" id="export-${c.name}" checked onclick="event.stopPropagation()" onchange="updateExportSelection('${c.name}', this.checked)">
            <div class="collection-info">
              <div class="collection-name">${c.name}</div>
              <div class="collection-meta">${c.variableCount} variables • Modes: ${c.modes.join(', ')}</div>
              <div class="collection-types" id="types-${c.name}">
                ${renderTypeBadges(c.types || {})}
              </div>
              ${modeCheckboxes}
            </div>
          </div>
        `;
      }).join('');

      // Detect and display source file plan
      updateExportDetectedPlan();
      
      updateExportPreview();
    }

    // Toggle export mode selection
    function toggleExportMode(collectionName, modeName, checked) {
      if (!selectedExportModes.has(collectionName)) {
        const col = collections.find(c => c.name === collectionName);
        selectedExportModes.set(collectionName, new Set(col?.modes || []));
      }
      
      const modes = selectedExportModes.get(collectionName);
      if (checked) {
        modes.add(modeName);
      } else {
        modes.delete(modeName);
      }
      
      // If no modes selected, deselect the collection
      if (modes.size === 0) {
        selectedExportCollections.delete(collectionName);
        const checkbox = document.getElementById(`export-${collectionName}`);
        if (checkbox) checkbox.checked = false;
      }
      
      updateExportPreview();
    }
    // Detect and display the source file's Figma plan based on mode count
    function updateExportDetectedPlan() {
      const section = document.getElementById('export-detected-plan-section');
      const planValue = document.getElementById('export-detected-plan-value');
      const planDetail = document.getElementById('export-detected-plan-detail');
      const planHint = document.getElementById('export-plan-hint');
      
      if (!section || collections.length === 0) {
        if (section) section.classList.add('hidden');
        return;
      }
      
      // Find max modes across all collections
      let maxModes = 1;
      collections.forEach(c => {
        if (c.modes && c.modes.length > maxModes) {
          maxModes = c.modes.length;
        }
      });
      
      // Determine plan based on max modes
      let plan = 'Starter';
      let detail = '1 mode per collection';
      let hint = '💡 Any Figma plan can import this file.';
      
      if (maxModes > 20) {
        plan = 'Enterprise';
        detail = `${maxModes} modes detected (unlimited)`;
        hint = '⚠️ Target file needs Enterprise plan for unlimited modes.';
      } else if (maxModes > 10) {
        plan = 'Organization';
        detail = `${maxModes} modes detected (up to 20)`;
        hint = '⚠️ Target file needs Organization or Enterprise plan.';
      } else if (maxModes > 1) {
        plan = 'Professional';
        detail = `${maxModes} modes detected (up to 10)`;
        hint = '💡 Target file needs Professional plan or higher.';
      }
      
      if (planValue) planValue.textContent = plan;
      if (planDetail) planDetail.textContent = detail;
      if (planHint) planHint.innerHTML = hint;
      
      section.classList.remove('hidden');
    }

    // Show empty state when no collections AND no styles exist
    function showEmptyStructureState() {
      const previewSection = document.getElementById('export-preview-section');
      const statsEl = document.getElementById('export-preview-stats');
      const treeEl = document.getElementById('export-preview-tree');
      
      previewSection.classList.remove('hidden');
      statsEl.innerHTML = `
        <div class="empty-state">
          <div class="empty-icon">📭</div>
          <div class="empty-title">No structure detected</div>
          <div class="empty-desc">This file has no variable collections or styles to export.</div>
        </div>
      `;
      treeEl.innerHTML = '';
    }

    function updateStyleCheckboxLabels() {
      // Update style count displays
      document.getElementById('text-style-count').textContent = `(${stylesInfo.textStyles})`;
      document.getElementById('color-style-count').textContent = `(${stylesInfo.colorStyles})`;
      document.getElementById('effect-style-count').textContent = `(${stylesInfo.effectStyles})`;
      document.getElementById('grid-style-count').textContent = `(${stylesInfo.gridStyles})`;
      
      // Auto-check if styles exist, uncheck if none
      document.getElementById('export-text-styles').checked = stylesInfo.textStyles > 0;
      document.getElementById('export-color-styles').checked = stylesInfo.colorStyles > 0;
      document.getElementById('export-effect-styles').checked = stylesInfo.effectStyles > 0;
      document.getElementById('export-grid-styles').checked = stylesInfo.gridStyles > 0;
      
      // Disable checkboxes if no styles available
      document.getElementById('export-text-styles').disabled = stylesInfo.textStyles === 0;
      document.getElementById('export-color-styles').disabled = stylesInfo.colorStyles === 0;
      document.getElementById('export-effect-styles').disabled = stylesInfo.effectStyles === 0;
      document.getElementById('export-grid-styles').disabled = stylesInfo.gridStyles === 0;
      
      // Grey out labels for disabled styles
      document.getElementById('text-styles-label').style.opacity = stylesInfo.textStyles === 0 ? '0.5' : '1';
      document.getElementById('color-styles-label').style.opacity = stylesInfo.colorStyles === 0 ? '0.5' : '1';
      document.getElementById('effect-styles-label').style.opacity = stylesInfo.effectStyles === 0 ? '0.5' : '1';
      document.getElementById('grid-styles-label').style.opacity = stylesInfo.gridStyles === 0 ? '0.5' : '1';
      
      updateExportPreview();
    }

    function selectAllStyles(select) {
      if (stylesInfo.textStyles > 0) document.getElementById('export-text-styles').checked = select;
      if (stylesInfo.colorStyles > 0) document.getElementById('export-color-styles').checked = select;
      if (stylesInfo.effectStyles > 0) document.getElementById('export-effect-styles').checked = select;
      if (stylesInfo.gridStyles > 0) document.getElementById('export-grid-styles').checked = select;
      updateExportPreview();
    }

    function renderTypeBadges(types) {
      const badges = [];
      if (types.color) badges.push(`<span class="type-badge type-color">${types.color} colors</span>`);
      if (types.float) badges.push(`<span class="type-badge type-float">${types.float} numbers</span>`);
      if (types.boolean) badges.push(`<span class="type-badge type-boolean">${types.boolean} booleans</span>`);
      if (types.string) badges.push(`<span class="type-badge type-string">${types.string} strings</span>`);
      return badges.join('');
    }

    function toggleExportCollection(name) {
      const checkbox = document.getElementById(`export-${name}`);
      checkbox.checked = !checkbox.checked;
      updateExportSelection(name, checkbox.checked);
    }

    function updateExportSelection(name, selected) {
      if (selected) {
        selectedExportCollections.add(name);
      } else {
        selectedExportCollections.delete(name);
      }
      updateExportPreview();
    }

    function selectAllExport(select) {
      collections.forEach(c => {
        const checkbox = document.getElementById(`export-${c.name}`);
        if (checkbox) {
          checkbox.checked = select;
          if (select) {
            selectedExportCollections.add(c.name);
          } else {
            selectedExportCollections.delete(c.name);
          }
        }
      });
      updateExportPreview();
    }

    // Update the library warning note based on preserve checkbox state
    function updateLibraryWarningNote() {
      const preserveCheckbox = document.getElementById('export-preserve-library-refs');
      const warningNote = document.getElementById('library-warning-note');
      
      if (!warningNote) return;
      
      if (preserveCheckbox && preserveCheckbox.checked) {
        warningNote.textContent = '✅ Library references will be preserved in export.';
      } else {
        warningNote.textContent = '⚠️ Only local variables will be exported. Library references will use raw values.';
      }
    }

    function updateExportPreview() {
      const previewSection = document.getElementById('export-preview-section');
      const emptyPreview = document.getElementById('export-empty-preview');
      const emptyPreviewOrder = document.getElementById('export-empty-preview-order');
      const statsEl = document.getElementById('export-preview-stats');
      const treeEl = document.getElementById('export-preview-tree');
      const copyDownloadBtns = document.getElementById('export-copy-download-btns');

      // Get style checkbox states
      const includeColorStyles = document.getElementById('export-color-styles').checked;
      const includeTextStyles = document.getElementById('export-text-styles').checked;
      const includeEffectStyles = document.getElementById('export-effect-styles').checked;
      const includeGridStyles = document.getElementById('export-grid-styles').checked;
      const hasStylesSelected = includeColorStyles || includeTextStyles || includeEffectStyles || includeGridStyles;

      // Update include images checkbox - only shown when color styles is checked in Advanced mode
      const includeImagesCheckbox = document.getElementById('export-include-images');
      const includeImagesLabel = document.getElementById('include-images-label');
      const imageWarningBanner = document.getElementById('image-warning-banner');
      if (includeImagesCheckbox && includeImagesLabel) {
        if (includeColorStyles && isAdvancedMode()) {
          includeImagesLabel.style.display = '';
          // Default to checked when showing (user can uncheck to exclude images)
          // Only set to checked if it wasn't explicitly unchecked by user
        } else {
          includeImagesLabel.style.display = 'none';
          // Don't reset checkbox state here - Simple mode handles images automatically
        }
        // Show warning banner in Status Check if images are enabled
        if (imageWarningBanner) {
          if (includeImagesCheckbox.checked) {
            imageWarningBanner.classList.remove('hidden');
            // Scroll Status Check column to top to show the warning
            const statusCheckBody = document.getElementById('status-check-column-body');
            if (statusCheckBody) {
              statusCheckBody.scrollTop = 0;
            }
          } else {
            imageWarningBanner.classList.add('hidden');
          }
          updateStatusCheckVisibility();
        }
      }

      if (selectedExportCollections.size === 0 && !hasStylesSelected) {
        previewSection.classList.add('hidden');
        if (emptyPreview) emptyPreview.classList.remove('hidden');
        if (emptyPreviewOrder) emptyPreviewOrder.classList.remove('hidden');
        if (copyDownloadBtns) copyDownloadBtns.style.display = 'none';
        statsEl.innerHTML = '';
        return;
      }

      previewSection.classList.remove('hidden');
      if (emptyPreview) emptyPreview.classList.add('hidden');
      if (emptyPreviewOrder) emptyPreviewOrder.classList.add('hidden');

      // Calculate variable stats
      let totalVars = 0;
      let totalColors = 0;
      let totalNumbers = 0;
      let totalStrings = 0;
      let totalBooleans = 0;
      
      const selectedCols = collections.filter(c => selectedExportCollections.has(c.name));
      selectedCols.forEach(c => {
        totalVars += c.variableCount;
        if (c.types) {
          totalColors += c.types.color || 0;
          totalNumbers += c.types.float || 0;
          totalStrings += c.types.string || 0;
          totalBooleans += c.types.boolean || 0;
        }
      });

      // Calculate selected styles count
      let selectedColorStyles = includeColorStyles ? stylesInfo.colorStyles : 0;
      let selectedTextStyles = includeTextStyles ? stylesInfo.textStyles : 0;
      let selectedEffectStyles = includeEffectStyles ? stylesInfo.effectStyles : 0;
      let selectedGridStyles = includeGridStyles ? stylesInfo.gridStyles : 0;
      let totalStyles = selectedColorStyles + selectedTextStyles + selectedEffectStyles + selectedGridStyles;
      let totalItems = totalVars + totalStyles;

      // Update fixed Total header
      const totalHeader = document.getElementById('export-stats-total-header');
      const totalValueEl = document.getElementById('export-total-value');
      if (totalHeader && totalValueEl) {
        if (totalItems > 0) {
          totalValueEl.textContent = totalItems;
          totalHeader.classList.remove('hidden');
        } else {
          totalHeader.classList.add('hidden');
        }
      }

      // Build stats HTML with separated Variables and Styles sections
      let statsHtml = '';
      
      // Variables section - 2x3 grid
      if (selectedExportCollections.size > 0) {
        statsHtml += `
          <div class="stats-section">
            <div class="stats-section-title">📦 Variables</div>
            <div class="stats-row">
              <div class="stat-card">
                <span class="stat-value">${totalColors}</span>
                <span class="stat-label">Colors</span>
              </div>
              <div class="stat-card">
                <span class="stat-value">${totalNumbers}</span>
                <span class="stat-label">Numbers</span>
              </div>
            </div>
            <div class="stats-row">
              <div class="stat-card">
                <span class="stat-value">${totalStrings}</span>
                <span class="stat-label">Strings</span>
              </div>
              <div class="stat-card">
                <span class="stat-value">${totalBooleans}</span>
                <span class="stat-label">Booleans</span>
              </div>
            </div>
            <div class="stats-row">
              <div class="stat-card">
                <span class="stat-value">${selectedExportCollections.size}</span>
                <span class="stat-label">Collections</span>
              </div>
              <div class="stat-card stat-total">
                <span class="stat-value">${totalVars}</span>
                <span class="stat-label">Total</span>
              </div>
            </div>
          </div>
        `;
      }
      
      // Styles section - 2x2 grid (top row has 3 items, bottom has 2)
      if (hasStylesSelected && totalStyles > 0) {
        statsHtml += `
          <div class="stats-section">
            <div class="stats-section-title">🎨 Styles</div>
            <div class="stats-row stats-row-3col">
              <div class="stat-card">
                <span class="stat-value">${selectedTextStyles}</span>
                <span class="stat-label">Text</span>
              </div>
              <div class="stat-card">
                <span class="stat-value">${selectedColorStyles}</span>
                <span class="stat-label">Color</span>
              </div>
              <div class="stat-card">
                <span class="stat-value">${selectedEffectStyles}</span>
                <span class="stat-label">Effect</span>
              </div>
            </div>
            <div class="stats-row">
              <div class="stat-card">
                <span class="stat-value">${selectedGridStyles}</span>
                <span class="stat-label">Layout Guide</span>
              </div>
              <div class="stat-card stat-total">
                <span class="stat-value">${totalStyles}</span>
                <span class="stat-label">Total</span>
              </div>
            </div>
          </div>
        `;
      }

      statsEl.innerHTML = statsHtml;

      // Build tree preview
      let tree = '';
      selectedCols.forEach(c => {
        tree += `<div class="tree-collection"><span class="tree-collection-name">📁 ${c.name}</span>`;
        c.modes.forEach(m => {
          tree += `<div class="tree-mode">📂 ${m}</div>`;
        });
        tree += `<div class="tree-var">... ${c.variableCount} variables</div></div>`;
      });
      
      // Add styles to tree if selected
      if (hasStylesSelected && totalStyles > 0) {
        tree += `<div class="tree-collection"><span class="tree-collection-name">🎨 Styles</span>`;
        if (selectedColorStyles > 0) {
          tree += `<div class="tree-mode">🎨 ${selectedColorStyles} Color Styles</div>`;
        }
        if (selectedTextStyles > 0) {
          tree += `<div class="tree-mode">📝 ${selectedTextStyles} Text Styles</div>`;
        }
        if (selectedEffectStyles > 0) {
          tree += `<div class="tree-mode">✨ ${selectedEffectStyles} Effect Styles</div>`;
        }
        if (selectedGridStyles > 0) {
          tree += `<div class="tree-mode">📐 ${selectedGridStyles} Grid Styles</div>`;
        }
        tree += `</div>`;
      }
      
      treeEl.innerHTML = tree;
    }

    function exportVariables() {
      if (selectedExportCollections.size === 0) {
        addLog('❌ Please select at least one collection', 'error');
        return;
      }
      
      const styleOptions = {
        colorStyles: document.getElementById('export-color-styles').checked,
        textStyles: document.getElementById('export-text-styles').checked,
        effectStyles: document.getElementById('export-effect-styles').checked,
        gridStyles: document.getElementById('export-grid-styles').checked
      };
      
      // In Simple mode, always include images when color styles are selected
      // In Advanced mode, use the checkbox value
      const includeImages = isAdvancedMode() 
        ? document.getElementById('export-include-images').checked
        : styleOptions.colorStyles; // Auto-include images in Simple mode when exporting color styles
      
      // In Simple mode, use sensible defaults; in Advanced mode, use selected options
      const preserveLibraryRefs = isAdvancedMode() 
        ? (document.getElementById('export-preserve-library-refs')?.checked || false)
        : true; // Always preserve in Simple mode
      const namingConvention = isAdvancedMode()
        ? (document.getElementById('export-naming-convention')?.value || 'original')
        : 'original'; // Always original in Simple mode
      const exportFormat = isAdvancedMode()
        ? (document.getElementById('export-format')?.value || 'figma')
        : 'figma'; // Always Figma JSON in Simple mode
      const resolveAliases = isAdvancedMode()
        ? (document.getElementById('export-resolve-aliases')?.checked || false)
        : false; // Keep aliases in Simple mode
      
      // Build selectedModes map (only in Advanced mode, otherwise export all modes)
      let selectedModesMap = null;
      if (isAdvancedMode()) {
        selectedModesMap = {};
        selectedExportCollections.forEach(colName => {
          const modes = selectedExportModes.get(colName);
          if (modes && modes.size > 0) {
            selectedModesMap[colName] = Array.from(modes);
          }
        });
      }
      
      if (includeImages) {
        addLog(`📤 Exporting ${selectedExportCollections.size} collections with image data...`);
      } else {
        addLog(`📤 Exporting ${selectedExportCollections.size} collections...`);
      }
      
      if (namingConvention !== 'original') {
        addLog(`🎯 Using ${namingConvention} naming convention`, 'info');
      }
      
      if (preserveLibraryRefs && window.detectedLibraryDeps?.length > 0) {
        addLog(`📚 Preserving library references: ${window.detectedLibraryDeps.join(', ')}`, 'info');
      }
      
      if (exportFormat === 'w3c') {
        addLog(`📄 Using W3C Design Tokens format`, 'info');
      }
      
      if (resolveAliases) {
        addLog(`🔓 Resolving aliases to raw values`, 'info');
      }
      
      parent.postMessage({ 
        pluginMessage: { 
          type: 'export',
          collections: Array.from(selectedExportCollections),
          styleOptions: styleOptions,
          includeImages: includeImages,
          preserveLibraryRefs: preserveLibraryRefs,
          namingConvention: namingConvention,
          exportFormat: exportFormat,
          selectedModes: selectedModesMap,
          resolveAliases: resolveAliases
        } 
      }, '*');
    }
    
    // Update format help text
    function updateFormatHelp() {
      const format = document.getElementById('export-format')?.value || 'figma';
      const helpEl = document.getElementById('export-format-help');
      if (helpEl) {
        if (format === 'w3c') {
          helpEl.textContent = 'Export to W3C Design Tokens (Style Dictionary compatible)';
        } else {
          helpEl.textContent = 'Export to Figma JSON Format';
        }
      }
    }

    function copyExport() {
      if (!exportData || exportData.trim() === '') {
        addLog('⚠️ No export data to copy. Run export first.', 'warning');
        return;
      }
      
      // Try execCommand first (works better in Figma plugin iframe)
      function fallbackCopy() {
        try {
          var textarea = document.createElement('textarea');
          textarea.value = exportData;
          textarea.style.position = 'fixed';
          textarea.style.left = '-9999px';
          textarea.style.top = '0';
          document.body.appendChild(textarea);
          textarea.focus();
          textarea.select();
          var success = document.execCommand('copy');
          document.body.removeChild(textarea);
          if (success) {
            addLog('📋 Copied to clipboard!', 'success');
          } else {
            addLog('❌ Copy command failed. Use Download instead.', 'error');
          }
        } catch (e) {
          addLog('❌ Failed to copy: ' + e + '. Use Download instead.', 'error');
        }
      }
      
      // In Figma plugin iframe, clipboard API is often unavailable or restricted
      // Use fallback method directly which works better in sandboxed environments
      fallbackCopy();
    }

    function downloadExport() {
      const blob = new Blob([exportData], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'export.json';
      a.click();
      URL.revokeObjectURL(url);
      addLog('💾 Downloaded export.json', 'success');
    }

    // ========== IMPORT ==========

    // Simplified parseImportPreview - reuses showImportSkeletons and parseImportPreviewAsync
    function parseImportPreview() {
      showImportSkeletons();
      const data = document.getElementById('import-input').value.trim();
      if (data) {
        parseImportPreviewAsync();
      }
    }
    
    function handleEmptyImportState() {
      const statsSection = document.getElementById('import-stats-section');
      const treeSection = document.getElementById('import-preview-tree-section');
      const orderEmptyPreview = document.getElementById('import-empty-preview-order');
      const treeEmptyPreview = document.getElementById('import-empty-preview-tree');
      const totalHeader = document.getElementById('import-stats-total-header');
      const planSection = document.getElementById('plan-selection-section');
      const modeSelectionContainer = document.getElementById('mode-selection-container');
      const importBtn = document.getElementById('import-btn');
      const statusEl = document.getElementById('import-status');
      
      if (statsSection) statsSection.style.display = 'none';
      if (treeSection) treeSection.classList.add('hidden');
      if (orderEmptyPreview) orderEmptyPreview.style.display = 'flex';
      if (treeEmptyPreview) treeEmptyPreview.style.display = 'flex';
      if (totalHeader) totalHeader.classList.add('hidden');
      if (planSection) planSection.classList.add('hidden');
      if (modeSelectionContainer) modeSelectionContainer.classList.add('hidden');
      importBtn.disabled = true;
      if (statusEl) statusEl.textContent = 'Load a JSON file to begin';
      importData = null;
      selectedModes = {};
      collectionModes = {};
      document.getElementById('validation-results').innerHTML = '';
      const clearBtn = document.getElementById('import-clear-btn');
      if (clearBtn) clearBtn.disabled = true;
    }
    
    async function parseImportPreviewAsync() {
      const data = document.getElementById('import-input').value.trim();
      if (!data) return;
      
      const orderEmptyPreview = document.getElementById('import-empty-preview-order');
      const treeEmptyPreview = document.getElementById('import-empty-preview-tree');
      const statsSection = document.getElementById('import-stats-section');
      const treeSection = document.getElementById('import-preview-tree-section');
      const planSection = document.getElementById('plan-selection-section');
      const modeSelectionContainer = document.getElementById('mode-selection-container');
      const importBtn = document.getElementById('import-btn');
      const statusEl = document.getElementById('import-status');
      const totalHeader = document.getElementById('import-stats-total-header');
      const statusSkeleton = document.getElementById('import-status-skeleton');
      const previewSkeleton = document.getElementById('import-preview-skeleton');

      try {
        // Use async JSON parsing for large files
        const parsed = await parseJSONAsync(data);
        importData = parsed;
        
        // Reset mode selection state for new data
        selectedModes = {};
        collectionModes = {};
        
        if (!Array.isArray(parsed)) {
          throw new Error('Expected array format');
        }

        // Check for styles in the data (they would be at a specific index or have a special key)
        let variableCollections = [];
        let stylesData = null;
        
        parsed.forEach(item => {
          const keys = Object.keys(item);
          if (keys.length === 1 && keys[0] === '_styles') {
            stylesData = item._styles;
          } else {
            variableCollections.push(item);
          }
        });

        // Store parsed data for use when proceeding to selection
        parsedImportCollections = variableCollections;
        parsedImportStyles = stylesData;
        
        // Calculate totals for stats summary
        let totalCollections = variableCollections.length;
        let totalVariables = 0;
        let totalColors = 0;
        let totalNumbers = 0;
        let totalStrings = 0;
        let totalBooleans = 0;
        
        variableCollections.forEach((colObj, idx) => {
          const colName = Object.keys(colObj)[0];
          const col = colObj[colName];
          const modes = Object.keys(col.modes || {});
          
          // Count variables and types
          let varCount = 0;
          const types = { color: 0, float: 0, boolean: 0, string: 0 };
          
          modes.forEach(mode => {
            const modeVars = col.modes[mode];
            const flatVars = flattenObject(modeVars);
            varCount = Math.max(varCount, flatVars.length);
            flatVars.forEach(v => {
              if (v.$type) types[v.$type]++;
            });
          });
          
          // Normalize type counts (don't multiply by modes)
          Object.keys(types).forEach(t => {
            types[t] = Math.round(types[t] / Math.max(modes.length, 1));
          });
          
          // Add to totals
          totalVariables += varCount;
          totalColors += types.color;
          totalNumbers += types.float;
          totalStrings += types.string;
          totalBooleans += types.boolean;
        });
        
        // Calculate style totals
        let totalColorStyles = stylesData?.colorStyles?.length || 0;
        let totalTextStyles = stylesData?.textStyles?.length || 0;
        let totalEffectStyles = stylesData?.effectStyles?.length || 0;
        let totalGridStyles = stylesData?.gridStyles?.length || 0;
        let totalStyles = totalColorStyles + totalTextStyles + totalEffectStyles + totalGridStyles;
        
        // Build import stats summary HTML
        const statsSummary = document.getElementById('import-stats-summary');
        let statsHtml = '';
        
        // Variables section - 2x3 grid
        if (totalCollections > 0) {
          statsHtml += `
            <div class="stats-section">
              <div class="stats-section-title">📦 Variables</div>
              <div class="stats-row">
                <div class="stat-card">
                  <span class="stat-value">${totalColors}</span>
                  <span class="stat-label">Colors</span>
                </div>
                <div class="stat-card">
                  <span class="stat-value">${totalNumbers}</span>
                  <span class="stat-label">Numbers</span>
                </div>
              </div>
              <div class="stats-row">
                <div class="stat-card">
                  <span class="stat-value">${totalStrings}</span>
                  <span class="stat-label">Strings</span>
                </div>
                <div class="stat-card">
                  <span class="stat-value">${totalBooleans}</span>
                  <span class="stat-label">Booleans</span>
                </div>
              </div>
              <div class="stats-row">
                <div class="stat-card">
                  <span class="stat-value">${totalCollections}</span>
                  <span class="stat-label">Collections</span>
                </div>
                <div class="stat-card stat-total">
                  <span class="stat-value">${totalVariables}</span>
                  <span class="stat-label">Total</span>
                </div>
              </div>
            </div>
          `;
        }
        
        // Styles section - 2x2 grid (top row has 3 items)
        if (totalStyles > 0) {
          statsHtml += `
            <div class="stats-section">
              <div class="stats-section-title">🎨 Styles</div>
              <div class="stats-row stats-row-3col">
                <div class="stat-card">
                  <span class="stat-value">${totalTextStyles}</span>
                  <span class="stat-label">Text</span>
                </div>
                <div class="stat-card">
                  <span class="stat-value">${totalColorStyles}</span>
                  <span class="stat-label">Color</span>
                </div>
                <div class="stat-card">
                  <span class="stat-value">${totalEffectStyles}</span>
                  <span class="stat-label">Effect</span>
                </div>
              </div>
              <div class="stats-row">
                <div class="stat-card">
                  <span class="stat-value">${totalGridStyles}</span>
                  <span class="stat-label">Layout Guide</span>
                </div>
                <div class="stat-card stat-total">
                  <span class="stat-value">${totalStyles}</span>
                  <span class="stat-label">Total</span>
                </div>
              </div>
            </div>
          `;
        }
        
        statsSummary.innerHTML = statsHtml;
        
        // Hide skeletons now that content is ready
        if (statusSkeleton) statusSkeleton.classList.add('hidden');
        if (previewSkeleton) previewSkeleton.classList.add('hidden');
        
        // Show preview content, hide empty states
        if (statsSection) statsSection.style.display = 'flex';
        if (orderEmptyPreview) orderEmptyPreview.style.display = 'none';
        if (treeEmptyPreview) treeEmptyPreview.style.display = 'none';
        
        // Hide the validation empty state since we have content
        const validationEmpty = document.getElementById('import-validation-empty');
        if (validationEmpty) validationEmpty.classList.add('hidden');
        
        // Update total header
        const totalItems = totalVariables + totalColorStyles + totalTextStyles + totalEffectStyles + totalGridStyles;
        const totalValueEl = document.getElementById('import-total-value');
        if (totalValueEl) totalValueEl.textContent = totalItems;
        if (totalHeader && totalItems > 0) {
          totalHeader.classList.remove('hidden');
        }
        
        // Calculate and show Import Asset Sources info
        const importAssetSourceBanner = document.getElementById('import-asset-source-banner');
        const importAssetSourceList = document.getElementById('import-asset-source-list');
        if (importAssetSourceBanner && importAssetSourceList) {
          let sourceHtml = '';
          // Count local variables
          if (totalVariables > 0) {
            sourceHtml += `<span class="alert-item" style="border-color: #4CAF50;">✅ ${totalVariables} Variables</span>`;
          }
          // Count styles
          if (totalStyles > 0) {
            sourceHtml += `<span class="alert-item" style="border-color: #4CAF50;">✅ ${totalStyles} Styles</span>`;
          }
          // Count library references (aliases pointing to external collections)
          // Aliases in JSON are: $value: "{path.to.var}" and $collectionName for the target collection
          let libraryAliasCount = 0;
          let localAliasCount = 0;
          const localCollectionNames = new Set(variableCollections.map(c => Object.keys(c)[0]));
          variableCollections.forEach(colObj => {
            const colName = Object.keys(colObj)[0];
            const col = colObj[colName];
            const modes = Object.keys(col.modes || {});
            modes.forEach(mode => {
              const modeVars = col.modes[mode];
              const flatVars = flattenObject(modeVars);
              flatVars.forEach(v => {
                // Check if it's an alias: $value starts with "{" or has $libraryRef
                const isAlias = (typeof v.$value === 'string' && v.$value.startsWith('{')) || v.$libraryRef;
                if (isAlias) {
                  // Check if it's a library alias (has $libraryRef or $collectionName not in local)
                  const isLibrary = v.$libraryRef || (v.$collectionName && !localCollectionNames.has(v.$collectionName));
                  if (isLibrary) {
                    libraryAliasCount++;
                  } else {
                    localAliasCount++;
                  }
                }
              });
            });
          });
          // Normalize alias counts (don't multiply by modes)
          const totalModes = variableCollections.reduce((acc, c) => {
            const col = c[Object.keys(c)[0]];
            return acc + Object.keys(col.modes || {}).length;
          }, 0);
          const avgModes = totalModes / Math.max(variableCollections.length, 1);
          libraryAliasCount = Math.round(libraryAliasCount / Math.max(avgModes, 1));
          localAliasCount = Math.round(localAliasCount / Math.max(avgModes, 1));
          
          if (libraryAliasCount > 0) {
            sourceHtml += `<span class="alert-item" style="border-color: #FAAD14;">📚 ${libraryAliasCount} Library References</span>`;
          }
          if (sourceHtml) {
            importAssetSourceBanner.classList.remove('hidden');
            importAssetSourceList.innerHTML = sourceHtml;
          } else {
            importAssetSourceBanner.classList.add('hidden');
          }
        }
        
        // Calculate and show Import Variable Bindings info
        const importBindingsBanner = document.getElementById('import-bindings-info-banner');
        const importBindingsList = document.getElementById('import-bindings-info-list');
        if (importBindingsBanner && importBindingsList) {
          let bindingsHtml = '';
          // Count aliases - $value starts with "{" indicates an alias reference
          let libraryAliasCount = 0;
          let localAliasCount = 0;
          const localCollectionNames = new Set(variableCollections.map(c => Object.keys(c)[0]));
          variableCollections.forEach(colObj => {
            const colName = Object.keys(colObj)[0];
            const col = colObj[colName];
            const modes = Object.keys(col.modes || {});
            modes.forEach(mode => {
              const modeVars = col.modes[mode];
              const flatVars = flattenObject(modeVars);
              flatVars.forEach(v => {
                // Check if it's an alias: $value starts with "{" or has $libraryRef
                const isAlias = (typeof v.$value === 'string' && v.$value.startsWith('{')) || v.$libraryRef;
                if (isAlias) {
                  // Check if it's a library alias
                  const isLibrary = v.$libraryRef || (v.$collectionName && !localCollectionNames.has(v.$collectionName));
                  if (isLibrary) {
                    libraryAliasCount++;
                  } else {
                    localAliasCount++;
                  }
                }
              });
            });
          });
          // Normalize
          const totalModes = variableCollections.reduce((acc, c) => {
            const col = c[Object.keys(c)[0]];
            return acc + Object.keys(col.modes || {}).length;
          }, 0);
          const avgModes = totalModes / Math.max(variableCollections.length, 1);
          libraryAliasCount = Math.round(libraryAliasCount / Math.max(avgModes, 1));
          localAliasCount = Math.round(localAliasCount / Math.max(avgModes, 1));
          
          const totalAliases = localAliasCount + libraryAliasCount;
          if (totalAliases > 0) {
            bindingsHtml += `<span class="alert-item">🔗 ${totalAliases} Variable Aliases</span>`;
            if (localAliasCount > 0) {
              bindingsHtml += `<span class="alert-item" style="border-color: #4CAF50;">✅ ${localAliasCount} Local</span>`;
            }
            if (libraryAliasCount > 0) {
              bindingsHtml += `<span class="alert-item" style="border-color: #FAAD14;">📚 ${libraryAliasCount} Library</span>`;
            }
          }
          // Count style-to-variable bindings
          let styleBindings = 0;
          if (stylesData?.colorStyles) {
            stylesData.colorStyles.forEach(style => {
              if (style.paints) {
                style.paints.forEach(paint => {
                  if (paint.boundVariableName) styleBindings++;
                });
              }
            });
          }
          if (styleBindings > 0) {
            bindingsHtml += `<span class="alert-item">🎨 ${styleBindings} Styles → Variables</span>`;
          }
          if (bindingsHtml) {
            importBindingsBanner.classList.remove('hidden');
            importBindingsList.innerHTML = bindingsHtml;
          } else {
            importBindingsBanner.classList.add('hidden');
          }
        }
        
        // Initialize scroll fade for import preview
        initImportPreviewScrollFade();
        
        // Build tree view
        buildImportTreeView(variableCollections, stylesData);
        
        if (planSection) planSection.classList.remove('hidden');
        
        // Enable proceed button (not import button - that's enabled after proceeding)
        const proceedBtn = document.getElementById('import-proceed-btn');
        if (proceedBtn) proceedBtn.disabled = false;
        importBtn.disabled = true; // Keep disabled until user proceeds to selection
        
        let statusText = `${variableCollections.length} collection(s)`;
        if (stylesData) statusText += ' + styles';
        statusText += ' ready • Click "Proceed to Selection"';
        if (statusEl) statusEl.textContent = statusText;
        addLog(`📋 Parsed ${variableCollections.length} collections from JSON`, 'success', 'import');
        
        // Detect library references in the import data
        const libraryRefsInJson = detectLibraryRefsInImportData(parsed);
        const importLibraryOption = document.getElementById('import-library-option');
        if (libraryRefsInJson.length > 0) {
          if (importLibraryOption) {
            importLibraryOption.classList.remove('hidden');
          }
          addLog(`📚 Detected external library references: ${libraryRefsInJson.join(', ')}`, 'info', 'import');
        } else {
          if (importLibraryOption) {
            importLibraryOption.classList.add('hidden');
          }
        }
        
        // Trigger validation with current plan
        validateImport();
        
        // Update source JSON plan banner for pre-proceed section
        updateSourceJsonPlanBanner();
        
        // Also detect Figma file plan from existing collections
        parent.postMessage({ pluginMessage: { type: 'detect_plan' } }, '*');

      } catch (e) {
        // Hide skeletons on error
        if (statusSkeleton) statusSkeleton.classList.add('hidden');
        if (previewSkeleton) previewSkeleton.classList.add('hidden');
        
        // Show empty states, hide content
        if (statsSection) statsSection.style.display = 'none';
        if (treeSection) treeSection.classList.add('hidden');
        if (orderEmptyPreview) orderEmptyPreview.style.display = 'flex';
        if (treeEmptyPreview) treeEmptyPreview.style.display = 'flex';
        if (totalHeader) totalHeader.classList.add('hidden');
        if (planSection) planSection.classList.add('hidden');
        importBtn.disabled = true;
        
        // Also disable proceed button on error
        const proceedBtn = document.getElementById('import-proceed-btn');
        if (proceedBtn) proceedBtn.disabled = true;
        
        if (statusEl) statusEl.textContent = '❌ Invalid JSON format';
        importData = null;
        addLog('❌ Invalid JSON: ' + e.message, 'error', 'import');
      }
    }

    function flattenObject(obj, prefix = '') {
      const results = [];
      for (const key in obj) {
        const val = obj[key];
        // Detect variable values: has $type, $value, or $alias
        if (val && typeof val === 'object' && ('$type' in val || '$value' in val || '$alias' in val)) {
          results.push(val);
        } else if (val && typeof val === 'object') {
          results.push(...flattenObject(val, prefix + key + '/'));
        }
      }
      return results;
    }

    // Initialize scroll fade for import preview stats
    function initImportPreviewScrollFade() {
      const scrollContent = document.getElementById('import-preview-stats-scroll-content');
      const fadeTop = document.getElementById('import-preview-stats-fade-top');
      const fadeBottom = document.getElementById('import-preview-stats-fade-bottom');
      if (!scrollContent || !fadeTop || !fadeBottom) return;

      function updateScrollFade() {
        requestAnimationFrame(() => {
          const scrollHeight = scrollContent.scrollHeight;
          const clientHeight = scrollContent.clientHeight;
          const scrollTop = scrollContent.scrollTop;
          const isScrollable = scrollHeight > clientHeight;

          // Show top fade when scrolled down
          if (scrollTop > 10) {
            fadeTop.classList.add('visible');
          } else {
            fadeTop.classList.remove('visible');
          }

          // Show bottom fade when not at bottom
          if (isScrollable && (scrollTop + clientHeight < scrollHeight - 10)) {
            fadeBottom.classList.add('visible');
          } else {
            fadeBottom.classList.remove('visible');
          }
        });
      }

      // Throttle scroll events for better performance
      const throttledUpdate = throttle(updateScrollFade, 16); // ~60fps
      scrollContent.addEventListener('scroll', throttledUpdate, { passive: true });
      setTimeout(updateScrollFade, 100);
      // Debounce mutation observer
      const debouncedUpdate = debounce(updateScrollFade, 50);
      const observer = new MutationObserver(debouncedUpdate);
      observer.observe(scrollContent, { childList: true, subtree: true });
    }

    // Build tree view for import preview (matches export tree structure)
    function buildImportTreeView(variableCollections, stylesData) {
      const treeSection = document.getElementById('import-preview-tree-section');
      const treeContainer = document.getElementById('import-preview-tree');
      const treeEmptyPreview = document.getElementById('import-empty-preview-tree');
      
      if (!treeContainer) return;
      
      // Use DocumentFragment for better performance
      const fragment = document.createDocumentFragment();
      const tempDiv = document.createElement('div');
      
      let treeHtml = '';
      
      // Build tree for variable collections (same structure as export)
      variableCollections.forEach(colObj => {
        const colName = Object.keys(colObj)[0];
        const col = colObj[colName];
        const modes = Object.keys(col.modes || {});
        
        // Count total variables in this collection - use fast method for large collections
        let varCount = 0;
        if (modes.length > 0) {
          const firstMode = col.modes[modes[0]];
          varCount = flattenObjectFast(firstMode).length;
        }
        
        treeHtml += `<div class="tree-collection"><span class="tree-collection-name">📁 ${colName}</span>`;
        modes.forEach(mode => {
          treeHtml += `<div class="tree-mode">📂 ${mode}</div>`;
        });
        treeHtml += `<div class="tree-var">... ${varCount} variables</div></div>`;
      });
      
      // Build tree for styles (same structure as export)
      if (stylesData) {
        const colorStyles = stylesData.colorStyles?.length || 0;
        const textStyles = stylesData.textStyles?.length || 0;
        const effectStyles = stylesData.effectStyles?.length || 0;
        const gridStyles = stylesData.gridStyles?.length || 0;
        const totalStyles = colorStyles + textStyles + effectStyles + gridStyles;
        
        if (totalStyles > 0) {
          treeHtml += `<div class="tree-collection"><span class="tree-collection-name">🎨 Styles</span>`;
          if (colorStyles > 0) {
            // For color styles, show paint type breakdown (optimized counting)
            let solidCount = 0, gradientCount = 0, imageCount = 0;
            const colorStylesArr = stylesData.colorStyles || [];
            for (let i = 0; i < colorStylesArr.length; i++) {
              const s = colorStylesArr[i];
              if (s.paints && Array.isArray(s.paints)) {
                for (let j = 0; j < s.paints.length; j++) {
                  const p = s.paints[j];
                  if (p.type === 'SOLID') solidCount++;
                  else if (p.type && p.type.startsWith('GRADIENT')) gradientCount++;
                  else if (p.type === 'IMAGE') imageCount++;
                }
              } else if (s.color) {
                solidCount++;
              }
            }
            let paintInfo = [];
            if (solidCount > 0) paintInfo.push(`${solidCount} solid`);
            if (gradientCount > 0) paintInfo.push(`${gradientCount} gradient`);
            if (imageCount > 0) paintInfo.push(`${imageCount} image`);
            const paintDetail = paintInfo.length > 0 ? ` (${paintInfo.join(', ')})` : '';
            treeHtml += `<div class="tree-mode">🎨 ${colorStyles} Color Styles${paintDetail}</div>`;
          }
          if (textStyles > 0) {
            treeHtml += `<div class="tree-mode">📝 ${textStyles} Text Styles</div>`;
          }
          if (effectStyles > 0) {
            treeHtml += `<div class="tree-mode">✨ ${effectStyles} Effect Styles</div>`;
          }
          if (gridStyles > 0) {
            treeHtml += `<div class="tree-mode">📐 ${gridStyles} Grid Styles</div>`;
          }
          treeHtml += `</div>`;
        }
      }
      
      // Batch DOM update using RAF
      rafUpdate(() => {
        treeContainer.innerHTML = treeHtml;
        
        if (treeHtml) {
          if (treeSection) treeSection.classList.remove('hidden');
          if (treeEmptyPreview) treeEmptyPreview.style.display = 'none';
        }
      });
    }

    function toggleImportCollection(name) {
      const checkboxes = document.querySelectorAll('#import-collections input[type="checkbox"]');
      // Find the checkbox for this collection
      const item = Array.from(document.querySelectorAll('#import-collections .collection-item'))
        .find(el => el.querySelector('.collection-name').textContent === name);
      if (item) {
        const checkbox = item.querySelector('input[type="checkbox"]');
        checkbox.checked = !checkbox.checked;
        updateImportSelection(name, checkbox.checked);
      }
    }

    function updateImportSelection(name, selected) {
      if (selected) {
        selectedImportCollections.add(name);
      } else {
        selectedImportCollections.delete(name);
      }
      updateImportStatus();
      
      // Update preview stats to reflect selection change
      updateImportPreviewStats();
      
      // Re-check plan mismatch (may remove warning if exceeding collection is unchecked)
      checkPlanMismatch();
      
      // Re-validate import
      if (importData) {
        validateImport();
      }
    }

    function selectAllImport(select) {
      if (!importData) return;
      
      importData.forEach((colObj, idx) => {
        const colName = Object.keys(colObj)[0];
        const checkbox = document.getElementById(`import-col-${idx}`);
        if (checkbox) {
          checkbox.checked = select;
          if (select) {
            selectedImportCollections.add(colName);
          } else {
            selectedImportCollections.delete(colName);
          }
        }
      });
      updateImportStatus();
      
      // Update preview stats to reflect selection change
      updateImportPreviewStats();
      
      // Re-check plan mismatch
      checkPlanMismatch();
      
      // Re-validate import
      if (importData) {
        validateImport();
      }
    }

    function updateImportStatus() {
      // Use the unified updateImportButtonState to respect importPreviewReviewed flag
      updateImportButtonState();
    }

    function clearAllVariables() {
      if (!confirm('⚠️ This will delete ALL variable collections and variables in this file. This cannot be undone. Continue?')) {
        return;
      }
      addLog('🗑️ Clearing all variables...');
      parent.postMessage({ pluginMessage: { type: 'clear_variables' } }, '*');
    }

    function clearAllStyles() {
      if (!confirm('⚠️ This will delete ALL local styles (color, text, effect, grid) in this file. This cannot be undone. Continue?')) {
        return;
      }
      addLog('🗑️ Clearing all styles...');
      parent.postMessage({ pluginMessage: { type: 'clear_styles' } }, '*');
    }

    function clearAll() {
      if (!confirm('⚠️ This will delete ALL variables AND styles in this file. This cannot be undone. Continue?')) {
        return;
      }
      addLog('🗑️ Clearing everything...');
      parent.postMessage({ pluginMessage: { type: 'clear_all' } }, '*');
    }

    // Store pending import for modal confirmation
    let pendingImportData = null;
    let pendingImportOptions = null;

    function importVariables() {
      if (!importData || selectedImportCollections.size === 0) {
        addLog('❌ Please select collections to import', 'error');
        return;
      }
      
      // Disable import button immediately to prevent double-clicks
      const importBtn = document.getElementById('import-btn');
      if (importBtn) {
        importBtn.disabled = true;
        importBtn.textContent = '⏳ Processing...';
      }

      // Filter import data to selected collections only (but keep _styles if present)
      let filteredData = importData.filter(colObj => {
        const colName = Object.keys(colObj)[0];
        return colName === '_styles' || selectedImportCollections.has(colName);
      });
      
      // If mode selection is active, filter modes in each collection
      const planInfo = PLAN_LIMITS[selectedPlan];
      if (Object.keys(selectedModes).length > 0 && planInfo.maxModes !== Infinity) {
        filteredData = filteredData.map(colObj => {
          const colName = Object.keys(colObj)[0];
          if (colName === '_styles') return colObj;
          
          const colData = colObj[colName];
          if (!colData || !colData.modes) return colObj;
          
          // Filter to only selected modes
          const selectedModesForCol = selectedModes[colName];
          if (!selectedModesForCol || selectedModesForCol.size === 0) return colObj;
          
          const filteredModes = {};
          for (const [modeName, modeData] of Object.entries(colData.modes)) {
            if (selectedModesForCol.has(modeName)) {
              filteredModes[modeName] = modeData;
            }
          }
          
          return { [colName]: { modes: filteredModes } };
        });
        
        addLog(`📥 Importing ${selectedImportCollections.size} collections with selected modes (${planInfo.name} plan limit: ${planInfo.maxModes})...`);
      } else {
        addLog(`📥 Importing ${selectedImportCollections.size} collections...`);
      }
      
      // Remove styles if none selected in the styles section
      const styleCheckboxes = document.querySelectorAll('#import-styles-options input[type="checkbox"]:checked');
      const includeStyles = styleCheckboxes.length > 0;
      let finalData = includeStyles ? filteredData : filteredData.filter(item => Object.keys(item)[0] !== '_styles');
      
      // Check if images should be included:
      // - Simple mode: always include images if present in JSON
      // - Advanced mode: only include if checkbox is checked
      const importImagesCheckbox = document.getElementById('import-include-images');
      const shouldStripImages = isAdvancedMode() && !importImagesCheckbox?.checked;
      
      // Strip image data from styles only in Advanced mode when checkbox is unchecked
      if (includeStyles && shouldStripImages) {
        finalData = stripImageDataFromStyles(finalData);
      }
      
      const useLibraryRefs = document.getElementById('import-use-library-refs')?.checked || false;
      
      // Check if there are library references in the import data and matching libraries available
      const libraryRefsInJson = detectLibraryRefsInImportData(finalData);
      
      // Determine merge/overwrite based on import behavior
      const importBehavior = getImportBehavior();
      const shouldMerge = importBehavior === 'smart-merge';
      const shouldOverwrite = true; // Always overwrite existing variables when they match
      
      // Get custom merge options if custom-merge is selected
      const customMergeOpts = importBehavior === 'custom-merge' ? getCustomMergeOptions() : null;
      
      if (libraryRefsInJson.length > 0 && !useLibraryRefs) {
        // Show modal to confirm library mapping
        pendingImportData = finalData;
        pendingImportOptions = {
          merge: shouldMerge || importBehavior === 'custom-merge',
          overwrite: shouldOverwrite,
          importStyles: includeStyles,
          useLibraryRefs: false,
          clearFirst: importBehavior === 'clean-import',
          customMerge: customMergeOpts,
          collectionBehaviors: isAdvancedMode() ? Object.fromEntries(collectionBehaviors) : null
        };
        showLibraryMappingModal(libraryRefsInJson);
        return;
      }

      // Proceed with import
      executeImport(finalData, {
        merge: shouldMerge || importBehavior === 'custom-merge',
        overwrite: shouldOverwrite,
        importStyles: includeStyles,
        useLibraryRefs: useLibraryRefs,
        clearFirst: importBehavior === 'clean-import',
        customMerge: customMergeOpts,
        collectionBehaviors: isAdvancedMode() ? Object.fromEntries(collectionBehaviors) : null
      });
    }
    
    // Strip image data (imageBase64, imageHash) from styles to prevent image import
    // Uses structuredClone for efficient deep cloning (falls back to JSON for compatibility)
    function stripImageDataFromStyles(data) {
      return data.map(colObj => {
        const colName = Object.keys(colObj)[0];
        if (colName !== '_styles') return colObj;
        
        const stylesData = colObj['_styles'];
        if (!stylesData) return colObj;
        
        // Deep clone - use structuredClone if available (faster), fallback to JSON
        let strippedStyles;
        if (typeof structuredClone === 'function') {
          strippedStyles = structuredClone(stylesData);
        } else {
          strippedStyles = JSON.parse(JSON.stringify(stylesData));
        }
        
        if (strippedStyles.colorStyles && Array.isArray(strippedStyles.colorStyles)) {
          strippedStyles.colorStyles = strippedStyles.colorStyles.map(style => {
            if (style.paints && Array.isArray(style.paints)) {
              style.paints = style.paints.map(paint => {
                // Remove image-related fields from IMAGE paints
                if (paint.type === 'IMAGE') {
                  const { imageBase64, imageHash, ...rest } = paint;
                  return rest;
                }
                return paint;
              });
            }
            return style;
          });
        }
        
        return { '_styles': strippedStyles };
      });
    }
    
    function detectLibraryRefsInImportData(data) {
      const libraryRefs = new Set();
      
      function scanObject(obj) {
        if (!obj || typeof obj !== 'object') return;
        
        // Check if this is a variable with library reference
        if (obj.$libraryName || obj.$collectionName) {
          if (obj.$collectionName && obj.$collectionName !== '') {
            libraryRefs.add(obj.$collectionName);
          }
        }
        
        // Recurse into nested objects
        for (const key of Object.keys(obj)) {
          if (key !== '$value' && typeof obj[key] === 'object') {
            scanObject(obj[key]);
          }
        }
      }
      
      data.forEach(colObj => {
        const colName = Object.keys(colObj)[0];
        if (colName !== '_styles') {
          scanObject(colObj[colName]);
        }
      });
      
      return Array.from(libraryRefs);
    }
    
    function showLibraryMappingModal(libraryRefs) {
      const modal = document.getElementById('libraryMappingModal');
      const listEl = document.getElementById('library-mapping-list');
      
      listEl.innerHTML = libraryRefs.map(name => 
        `<span class="alert-item" style="border-color: #4CAF50;">📚 ${name}</span>`
      ).join('');
      
      modal.classList.remove('hidden');
    }
    
    function closeLibraryMappingModal(useLibrary) {
      const modal = document.getElementById('libraryMappingModal');
      modal.classList.add('hidden');
      
      if (pendingImportData && pendingImportOptions) {
        // Update checkbox to reflect choice
        const checkbox = document.getElementById('import-use-library-refs');
        if (checkbox) {
          checkbox.checked = useLibrary;
        }
        
        pendingImportOptions.useLibraryRefs = useLibrary;
        
        if (useLibrary) {
          addLog('📚 Will map variables to external library bindings', 'info', 'import');
        } else {
          addLog('📦 Will use local values from JSON file', 'info', 'import');
        }
        
        executeImport(pendingImportData, pendingImportOptions);
        pendingImportData = null;
        pendingImportOptions = null;
      }
    }
    
    function executeImport(data, options) {
      // Hide undo section from previous import since we're starting a new one
      hideUndoSection();
      
      // First, take a snapshot of current state for undo capability
      addLog('📸 Capturing current state for undo...', 'info', 'import');
      
      // Store import data and options for after snapshot
      window._pendingImportAfterSnapshot = { data, options };
      
      parent.postMessage({
        pluginMessage: {
          type: 'create_undo_snapshot'
        }
      }, '*');
    }
    
    // Actually execute import after snapshot is captured (async for large data)
    async function executeImportAfterSnapshot(data, options) {
      try {
        const dataString = await stringifyJSONAsync(data);
        parent.postMessage({
          pluginMessage: {
            type: 'import',
            data: dataString,
            options: options
          }
        }, '*');
      } catch (err) {
        console.error('Import stringify error:', err);
        addLog('⚠️ Error preparing import data', 'error', 'import');
        showToast('Error preparing import data', 'error');
      }
    }
    
    // Undo last import - restores file to pre-import state
    function undoLastImport() {
      if (!lastImportSnapshot) {
        showToast('No import to undo', 'error');
        return;
      }
      
      if (!confirm('⚠️ This will undo the last import, restoring the file to its previous state. This cannot be undone. Continue?')) {
        return;
      }
      
      addLog('↩️ Undoing last import...', 'info', 'import');
      
      // Disable undo button during operation
      const undoBtn = document.getElementById('undo-import-btn');
      if (undoBtn) {
        undoBtn.disabled = true;
        undoBtn.innerHTML = '<span class="undo-icon">⏳</span> Undoing...';
      }
      
      parent.postMessage({
        pluginMessage: {
          type: 'undo_import',
          snapshot: lastImportSnapshot
        }
      }, '*');
    }
    
    // Hide undo section
    function hideUndoSection() {
      const undoSection = document.getElementById('import-undo-section');
      if (undoSection) {
        undoSection.classList.add('hidden');
      }
      lastImportSnapshot = null;
    }
    
    // Show undo section
    function showUndoSection() {
      const undoSection = document.getElementById('import-undo-section');
      if (undoSection) {
        undoSection.classList.remove('hidden');
      }
    }

    // File input handling
    const fileInput = document.getElementById('file-input');

    if (fileInput) {
      fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) handleFile(file);
        // Reset input value to allow selecting the same file again
        e.target.value = '';
      });
    }
    
    // Optimized paste handler for import textarea
    const importTextarea = document.getElementById('import-input');
    if (importTextarea) {
      importTextarea.addEventListener('paste', (e) => {
        // Show loading feedback immediately
        showImportSkeletons();
        clearFileLoadedIndicator();
        
        // Let the paste happen, then process with a slight delay
        // to ensure textarea value is updated
        setTimeout(() => {
          parseImportPreviewAsync();
        }, 0);
      });
    }

    function handleFile(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        document.getElementById('import-input').value = e.target.result;
        addLog('📁 Loaded: ' + file.name, 'success', 'import');
        
        // Show the loaded file indicator
        const fileIndicator = document.getElementById('import-file-loaded');
        const fileNameSpan = document.getElementById('import-file-name');
        if (fileIndicator && fileNameSpan) {
          fileNameSpan.textContent = file.name;
          fileIndicator.classList.remove('hidden');
        }
        
        parseImportPreview();
      };
      reader.readAsText(file);
    }

    // ========== INIT ==========

    function loadCollections() {
      parent.postMessage({ pluginMessage: { type: 'get_collections' } }, '*');
    }

    // Reset export state - clears stale data from previous files
    function resetExportState() {
      exportData = '';
      selectedExportCollections = new Set();
      const exportOutput = document.getElementById('export-output');
      if (exportOutput) exportOutput.value = '';
      
      // Hide JSON preview section
      const jsonPreviewSection = document.getElementById('export-json-preview-section');
      if (jsonPreviewSection) {
        jsonPreviewSection.classList.add('hidden');
      }
      
      // Hide Total header
      const totalHeader = document.getElementById('export-stats-total-header');
      if (totalHeader) {
        totalHeader.classList.add('hidden');
      }
    }

    // Reset import state - clears stale data from previous files
    function resetImportState() {
      importData = null;
      selectedImportCollections = new Set();
      selectedModes = {};
      collectionModes = {};
      lastValidation = null;
      libraryStatus = null;
      fontStatus = null;
      importWithLibraryLinks = true;
      document.getElementById('import-input').value = '';
      document.getElementById('file-input').value = '';
      document.getElementById('import-btn').disabled = true;
      document.getElementById('import-status').textContent = 'Load a JSON file to begin';
      
      // Hide content, show empty states in Preview column
      const statsSection = document.getElementById('import-stats-section');
      const treeSection = document.getElementById('import-preview-tree-section');
      const orderEmptyPreview = document.getElementById('import-empty-preview-order');
      const treeEmptyPreview = document.getElementById('import-empty-preview-tree');
      const totalHeader = document.getElementById('import-stats-total-header');
      
      if (statsSection) statsSection.style.display = 'none';
      if (treeSection) treeSection.classList.add('hidden');
      if (orderEmptyPreview) orderEmptyPreview.style.display = 'flex';
      if (treeEmptyPreview) treeEmptyPreview.style.display = 'flex';
      if (totalHeader) totalHeader.classList.add('hidden');
      
      // Reset validation area
      const validationEmpty = document.getElementById('import-validation-empty');
      const planSection = document.getElementById('plan-selection-section');
      if (validationEmpty) validationEmpty.classList.remove('hidden');
      if (planSection) planSection.classList.add('hidden');
      
      // Hide library and font status sections
      const libSection = document.getElementById('library-status-section');
      const fontSection = document.getElementById('font-status-section');
      if (libSection) libSection.classList.add('hidden');
      if (fontSection) fontSection.classList.add('hidden');
    }

    // Switch between Order and Tree tabs in Preview column (Export)
    function switchPreviewTab(tab) {
      const orderPanel = document.getElementById('export-order-panel');
      const treePanel = document.getElementById('export-tree-panel');
      const totalHeader = document.getElementById('export-stats-total-header');
      const tabs = document.querySelectorAll('#preview-column .column-tabs .column-tab');
      
      tabs.forEach(t => {
        if (t.dataset.tab === tab) {
          t.classList.add('active');
        } else {
          t.classList.remove('active');
        }
      });
      
      if (tab === 'order') {
        orderPanel.style.display = 'flex';
        orderPanel.classList.add('active');
        treePanel.style.display = 'none';
        treePanel.classList.remove('active');
        // Show total header if there are items (check stored value)
        const totalValue = document.getElementById('export-total-value');
        if (totalHeader && totalValue && parseInt(totalValue.textContent) > 0) {
          totalHeader.classList.remove('hidden');
        }
      } else {
        orderPanel.style.display = 'none';
        orderPanel.classList.remove('active');
        treePanel.style.display = 'flex';
        treePanel.classList.add('active');
        // Hide total header in tree view
        if (totalHeader) {
          totalHeader.classList.add('hidden');
        }
      }
    }

    // Switch between Order and Tree tabs in Preview column (Import)
    function switchImportPreviewTab(tab) {
      const orderPanel = document.getElementById('import-order-panel');
      const treePanel = document.getElementById('import-tree-panel');
      const totalHeader = document.getElementById('import-stats-total-header');
      const tabs = document.querySelectorAll('#import-preview-column .column-tabs .column-tab');
      
      tabs.forEach(t => {
        if (t.dataset.tab === 'import-' + tab) {
          t.classList.add('active');
        } else {
          t.classList.remove('active');
        }
      });
      
      if (tab === 'order') {
        orderPanel.style.display = 'flex';
        orderPanel.classList.add('active');
        treePanel.style.display = 'none';
        treePanel.classList.remove('active');
        // Show total header if there are items (check stored value)
        const totalValue = document.getElementById('import-total-value');
        if (totalHeader && totalValue && parseInt(totalValue.textContent) > 0) {
          totalHeader.classList.remove('hidden');
        }
      } else {
        orderPanel.style.display = 'none';
        orderPanel.classList.remove('active');
        treePanel.style.display = 'flex';
        treePanel.classList.add('active');
        // Hide total header in tree view
        if (totalHeader) {
          totalHeader.classList.add('hidden');
        }
      }
    }

    // Update Status Check column visibility based on alerts
    function updateStatusCheckVisibility() {
      const emptyStatus = document.getElementById('export-empty-status');
      const imageWarningBanner = document.getElementById('image-warning-banner');
      const assetSourceBanner = document.getElementById('asset-source-banner');
      const bindingsInfoBanner = document.getElementById('bindings-info-banner');
      const fontsUsedBanner = document.getElementById('fonts-used-banner');
      const libraryBanner = document.getElementById('library-warning-banner');
      const planCompatBanner = document.getElementById('plan-compatibility-banner');
      const fontBanner = document.getElementById('font-requirements-banner');
      
      // Check if any alert banners are visible
      const hasVisibleAlerts = 
        (imageWarningBanner && !imageWarningBanner.classList.contains('hidden')) ||
        (assetSourceBanner && !assetSourceBanner.classList.contains('hidden')) ||
        (bindingsInfoBanner && !bindingsInfoBanner.classList.contains('hidden')) ||
        (fontsUsedBanner && !fontsUsedBanner.classList.contains('hidden')) ||
        (libraryBanner && !libraryBanner.classList.contains('hidden')) ||
        (planCompatBanner && !planCompatBanner.classList.contains('hidden')) ||
        (fontBanner && !fontBanner.classList.contains('hidden'));
      
      if (emptyStatus) {
        if (hasVisibleAlerts) {
          emptyStatus.classList.add('hidden');
        } else {
          emptyStatus.classList.remove('hidden');
        }
      }
    }

    // Manual refresh - reloads collections and clears stale export data
    function refreshCollections() {
      addLog('🔄 Refreshing Variables & Styles...', 'info');
      
      // Reset all export state (clears preview, selections, output)
      resetExportState();
      
      // Also hide the preview section and clear collections array
      document.getElementById('export-preview-section').classList.add('hidden');
      collections = [];
      stylesInfo = { colorStyles: 0, textStyles: 0, effectStyles: 0, gridStyles: 0 };
      
      // Reload collections from Figma
      loadCollections();
      
      addLog('✅ Export Preview has been updated', 'success');
    }

    // Initialize - always start fresh
    resetExportState();
    resetImportState();
    loadCollections();
    
    // Detect Figma file plan on startup (for Import tab's Figma Plan accordion)
    parent.postMessage({ pluginMessage: { type: 'detect_plan' } }, '*');

    // ========== SCROLL FADE INDICATORS ==========
    function initScrollFade(containerId, listId) {
      const container = document.getElementById(containerId);
      const list = document.getElementById(listId);
      if (!container || !list) return;

      function updateScrollFade() {
        requestAnimationFrame(() => {
          const scrollTop = list.scrollTop;
          const scrollHeight = list.scrollHeight;
          const clientHeight = list.clientHeight;
          const isScrollable = scrollHeight > clientHeight;

          // Show top fade when scrolled down
          if (scrollTop > 10) {
            container.classList.add('scroll-top');
          } else {
            container.classList.remove('scroll-top');
          }

          // Show bottom fade when not at bottom
          if (isScrollable && (scrollTop + clientHeight < scrollHeight - 10)) {
            container.classList.add('scroll-bottom');
          } else {
            container.classList.remove('scroll-bottom');
          }
        });
      }

      // Throttle scroll events for better performance
      const throttledUpdate = throttle(updateScrollFade, 16); // ~60fps
      list.addEventListener('scroll', throttledUpdate, { passive: true });
      // Initial check
      setTimeout(updateScrollFade, 100);
      // Re-check when content might have changed (debounced)
      const debouncedUpdate = debounce(updateScrollFade, 50);
      const observer = new MutationObserver(debouncedUpdate);
      observer.observe(list, { childList: true, subtree: true });
    }

    // Initialize scroll fade for export collections
    initScrollFade('export-collections-container', 'export-collections');

    // ========== COLUMN BODY SCROLL FADE ==========
    function initColumnScrollFade(columnBodyId, fadeTopId, fadeBottomId) {
      const columnBody = document.getElementById(columnBodyId);
      const fadeTop = document.getElementById(fadeTopId);
      const fadeBottom = document.getElementById(fadeBottomId);
      if (!columnBody || !fadeTop || !fadeBottom) return;

      function updateScrollFade() {
        requestAnimationFrame(() => {
          const scrollHeight = columnBody.scrollHeight;
          const clientHeight = columnBody.clientHeight;
          const scrollTop = columnBody.scrollTop;
          const isScrollable = scrollHeight > clientHeight;

          // Show top fade when scrolled down
          if (scrollTop > 10) {
            fadeTop.classList.add('visible');
          } else {
            fadeTop.classList.remove('visible');
          }

          // Show bottom fade when not at bottom
          if (isScrollable && (scrollTop + clientHeight < scrollHeight - 10)) {
            fadeBottom.classList.add('visible');
          } else {
            fadeBottom.classList.remove('visible');
          }
        });
      }

      // Throttle scroll events for better performance
      const throttledUpdate = throttle(updateScrollFade, 16); // ~60fps
      columnBody.addEventListener('scroll', throttledUpdate, { passive: true });
      setTimeout(updateScrollFade, 100);
      // Debounce mutation observer updates
      const debouncedUpdate = debounce(updateScrollFade, 50);
      const observer = new MutationObserver(debouncedUpdate);
      observer.observe(columnBody, { childList: true, subtree: true });
    }

    // Initialize column scroll fade for Selection column
    initColumnScrollFade('selection-column-body', 'selection-fade-top', 'selection-fade-bottom');

    // Initialize column scroll fade for Status Check column
    initColumnScrollFade('status-check-column-body', 'status-check-fade-top', 'status-check-fade-bottom');

    // Initialize column scroll fade for Preview Order panel
    initColumnScrollFade('preview-stats-scroll-content', 'preview-stats-fade-top', 'preview-stats-fade-bottom');

    // Initialize column scroll fade for Import Input column
    initColumnScrollFade('import-input-column-body', 'import-input-fade-top', 'import-input-fade-bottom');

    // Initialize column scroll fade for Import Status column
    initColumnScrollFade('import-status-column-body', 'import-status-fade-top', 'import-status-fade-bottom');

    // Initialize column scroll fade for Import Preview panel
    initColumnScrollFade('import-preview-stats-scroll-content', 'import-preview-stats-fade-top', 'import-preview-stats-fade-bottom');

    // ========== TIP MODAL ==========
    function openTipModal() {
      document.getElementById('tipModal').classList.add('visible');
    }

    function closeTipModal() {
      document.getElementById('tipModal').classList.remove('visible');
    }

    // Close modal on overlay click
    document.getElementById('tipModal').addEventListener('click', function(e) {
      if (e.target === this) {
        closeTipModal();
      }
    });

    // Close modal on Escape key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        closeTipModal();
      }
    });
  </script>

  <!-- Persistent Footer -->
  <footer class="plugin-footer">
    <div class="footer-brand">
      Made with ♥ by <span>The Keep Collective</span>
    </div>
    <div class="footer-actions">
      <button class="footer-btn footer-btn-tip" onclick="openTipModal()">☕ Buy me a coffee</button>
      <a href="https://shop.tusharkantnaik.com" target="_blank" class="footer-btn footer-btn-shop">
        🛍️ Collector's Shop
      </a>
    </div>
  </footer>

  <!-- Library Mapping Confirmation Modal -->
  <div class="modal-overlay hidden" id="libraryMappingModal">
    <div class="modal" style="max-width: 420px;">
      <div class="modal-header">
        <div class="modal-title">📚 External Library Detected</div>
        <button class="modal-close" onclick="closeLibraryMappingModal(false)">×</button>
      </div>
      <div class="modal-body" style="padding: 16px;">
        <p style="margin-bottom: 12px;">The JSON file contains references to external libraries that appear to be available in this file:</p>
        <div id="library-mapping-list" class="alert-list" style="margin-bottom: 12px; background: #E8F5E9; padding: 10px; border-radius: 4px;"></div>
        <p style="margin-bottom: 12px; font-weight: 600;">Would you like to map variables to the external library and preserve bindings?</p>
        <p style="font-size: 10px; color: #666;">
          <strong>Yes:</strong> Variables will reference the external library (recommended if library is linked).<br>
          <strong>No:</strong> Variables will use local values from the JSON file.
        </p>
      </div>
      <div class="modal-actions" style="display: flex; gap: 8px; padding: 0 16px 16px;">
        <button class="btn btn-secondary" onclick="closeLibraryMappingModal(false)" style="flex: 1;">
          ✖️ No, use local values
        </button>
        <button class="btn btn-primary" onclick="closeLibraryMappingModal(true)" style="flex: 1; background: #4CAF50; border-color: #4CAF50;">
          ✅ Yes, map to library
        </button>
      </div>
    </div>
  </div>

  <!-- Tip Modal -->
  <div class="modal-overlay" id="tipModal">
    <div class="modal" style="max-width: 420px;">
      <div class="modal-header">
        <div class="modal-title">☕ Support My Work</div>
        <button class="modal-close" onclick="closeTipModal()">×</button>
      </div>
      <div class="tip-modal-landscape">
        <div class="tip-modal-qr-side">
          <a href="https://buymeacoffee.com/tusharkantnaik" target="_blank" class="tip-qr-link" onclick="closeTipModal()">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUoAAAFKAQAAAABTUiuoAAACbklEQVR4nO1bQY7iQAwsN5HmmEg8gKeEn6140v4geQo/oI8jBXlVdgeYyy6nxVLbh5DQPlhdKbtsGlG8aWt51xNI15KbhXxdUKXZuYpgne4iZwB+aTYkYRAgZQwADpvdCkaFzNcvJsf7ANTjhnnhUj1GiLV07zo0oAyyOkHXCWK1TFENqAmYf+dmxduBcYOceZGJmXDc/ncAf7fyj/X+XFWZCefbQePH2msmVH+oR2VO3B/NRj7UELGma6GicN3nWzLfmAQrUeRltaUpNyvEDkBfjYVq1EcmPLyuLR+PtXTvClUiM6uqqQxdiNGyQ/Z6V7rfrBKjbmEVL14q820SRRXoetrYg4Gq/pCvNoJkwg0t9Y1MeNiTYKOV1bLkVgi0bGShgvHbGfU0ma8k2GSkY0H7eKwlXUFNaGSSs8uKbzFG6WXidySYqUPkZpUgKoOmC1WGEqhHOnxmR02VgVB1a96Bctx48ZJFQDXRQgS0boTiiZuSYGa3fTX7rTho6c92+EkwtEYsuRUJrY2fOzw/ZbyPNny1fDrW0r0rjEytbnkStPGTTTXa2DC5FeV1QStKzq2HRHRG0Ui1rFtB0Cp2LgPsjq23Ejmx37oOjVu2yhYZIWLt3BWvY/Y9HXrJauI9J09BzzyBU4365TnRzOcbS5hYO3fFs6NqtPLGeFeCrRtLTRgCLXdtJwZt/FQfd/aj8nT3sSGixPqWlT5c5ZdpQmqLNohq50ARL9bOXesAvZxaOnSMTGpcUhNGrVu0Nm96dMd5LiMGWsP++xaNZ3V5qFpXsdPWh621WjxjjY/HWrp3lfxHEPJ1edtKuuJt+wMPUsU9+PAitgAAAABJRU5ErkJggg==" 
                 alt="Scan to support" 
                 style="width: 170px; height: 170px; border: 3px solid var(--color-border); border-radius: var(--border-radius); display: block;" />
          </a>
          <span class="tip-qr-label">Scan to support</span>
        </div>
        <div class="tip-modal-content-side">
          <div class="modal-body">
            <p>Hey! I'm an individual designer who builds tools to make life simpler.</p>
            <p>If this plugin saved you time, consider buying me a coffee. Every tip helps me keep building useful stuff!</p>
          </div>
          <div class="tip-options">
            <a href="https://buymeacoffee.com/tusharkantnaik" target="_blank" class="tip-btn tip-btn-bmc" onclick="closeTipModal()">
              ☕ Buy me a coffee
            </a>
          </div>
        </div>
      </div>
      <div class="modal-footer" style="font-size: 10px; padding-top: 12px; text-align: center;">
        No pressure — the plugin is free forever. 🫡
      </div>
    </div>
  </div>
</body>
</html>
