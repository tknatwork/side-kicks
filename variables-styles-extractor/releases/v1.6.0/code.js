"use strict";
/**
 * ‚òïÔ∏è Variables & Styles Extractor - Figma Plugin
 * Export and import Figma variables and styles with full fidelity
 *
 * @copyright 2025 Tushar Kant Naik / The Keep Collective
 * @license MIT - See LICENSE file
 * @version 1.6.0
 * @author Tushar Kant Naik <hi@tusharkantnaik.com>
 * @website https://tusharkantnaik.com
 */figma.showUI(__html__,{width:480,height:760,themeColors:!0,title:"‚òïÔ∏è Variables & Styles Extractor v1.6.0"});const Result={ok:e=>({ok:!0,value:e}),err:e=>({ok:!1,error:e})},Logger={log(e,t){console.log(`[Variables Extractor] ${e}`,t||""),figma.ui.postMessage({type:"log",message:e,data:t})},send(e,t){figma.ui.postMessage({type:e,data:t})}},PLAN_LIMITS={starter:{maxModesPerCollection:1,canPublishLibraries:!1,hasVariableRestApi:!1},professional:{maxModesPerCollection:10,canPublishLibraries:!0,hasVariableRestApi:!1},organization:{maxModesPerCollection:20,canPublishLibraries:!0,hasVariableRestApi:!1},enterprise:{maxModesPerCollection:1/0,canPublishLibraries:!0,hasVariableRestApi:!0}},MAX_VARIABLES_PER_COLLECTION=5e3;async function detectCurrentPlan(){const e=await figma.variables.getLocalVariableCollectionsAsync();let t,a=1;for(const t of e)t.modes.length>a&&(a=t.modes.length);return t=a>20?"enterprise":a>10?"organization":"professional",Object.assign({plan:t},PLAN_LIMITS[t])}async function validateImportAgainstPlan(e,t){const a=t?Object.assign({plan:t},PLAN_LIMITS[t]):await detectCurrentPlan(),o=await figma.variables.getLocalVariableCollectionsAsync(),s=o.reduce((e,t)=>Math.max(e,t.modes.length),0),i=(await figma.variables.getLocalVariablesAsync()).length,r=[];for(const t of e)"_styles"in t||r.push(t);let n=0,l=0;const c=[];for(const e of r){const t=Object.keys(e)[0],o=e[t];if(!o||!o.modes)continue;const s=Object.keys(o.modes).length;s>n&&(n=s),s>a.maxModesPerCollection&&c.push(`"${t}" (${s} modes, limit: ${a.maxModesPerCollection===1/0?"‚àû":a.maxModesPerCollection})`);const i=Object.values(o.modes)[0];i&&(l+=countNestedVariables(i))}const g=[],d=[];c.length;for(const e of r){const t=Object.keys(e)[0],a=e[t];if(!a||!a.modes)continue;const o=Object.values(a.modes)[0],s=o?countNestedVariables(o):0;s>5e3&&d.push(`Collection "${t}" has ${s} variables, exceeds limit of 5000`)}return l>1e3&&g.push(`Large import: ${l} variables. This may take a moment.`),r.length>10&&g.push(`Importing ${r.length} collections. Consider importing in batches.`),{currentPlan:a,existing:{collections:o.length,maxModesInAnyCollection:s,totalVariables:i},importing:{collections:r.length,maxModesInAnyCollection:n,totalVariables:l,collectionsExceedingModeLimit:c},warnings:g,errors:d,canImport:0===d.length}}function countNestedVariables(e,t=0){for(const[,a]of Object.entries(e))a&&"object"==typeof a&&("$type"in a&&"$value"in a?t++:t=countNestedVariables(a,t));return t}const MathUtils={round2:e=>Math.round(100*e)/100,clamp:(e,t,a)=>Math.max(t,Math.min(a,e)),toHexByte:e=>Math.round(255*e).toString(16).padStart(2,"0"),fromHexByte:e=>parseInt(e,16)/255};function calculateHue(e,t,a,o,s){if(o===s)return 0;const i=o-s;let r=0;switch(o){case e:r=((t-a)/i+(t<a?6:0))/6;break;case t:r=((a-e)/i+2)/6;break;case a:r=((e-t)/i+4)/6}return Math.round(360*r)}const ColorConverter={toHex(e){const t="#"+MathUtils.toHexByte(e.r)+MathUtils.toHexByte(e.g)+MathUtils.toHexByte(e.b),a=e.a;return void 0!==a&&a<1?t+MathUtils.toHexByte(a):t},toRgb255(e){const t={r:Math.round(255*e.r),g:Math.round(255*e.g),b:Math.round(255*e.b)},a=e.a;return void 0!==a&&a<1?Object.assign(Object.assign({},t),{a:MathUtils.round2(a)}):t},toCss(e){const t=Math.round(255*e.r),a=Math.round(255*e.g),o=Math.round(255*e.b),s=e.a,i=void 0!==s?MathUtils.round2(s):1;return i<1?`rgba(${t}, ${a}, ${o}, ${i})`:`rgb(${t}, ${a}, ${o})`},toHsl(e){const{r:t,g:a,b:o}=e,s=Math.max(t,a,o),i=Math.min(t,a,o),r=(s+i)/2;let n=0;if(s!==i){const e=s-i;n=r>.5?e/(2-s-i):e/(s+i)}const l={h:calculateHue(t,a,o,s,i),s:Math.round(100*n),l:Math.round(100*r)},c=e.a;return void 0!==c&&c<1?Object.assign(Object.assign({},l),{a:MathUtils.round2(c)}):l},toHsb(e){const{r:t,g:a,b:o}=e,s=Math.max(t,a,o),i=Math.min(t,a,o),r=0===s?0:(s-i)/s,n={h:calculateHue(t,a,o,s,i),s:Math.round(100*r),b:Math.round(100*s)},l=e.a;return void 0!==l&&l<1?Object.assign(Object.assign({},n),{a:MathUtils.round2(l)}):n},toAllFormats(e){return{hex:this.toHex(e),rgb:this.toRgb255(e),css:this.toCss(e),hsl:this.toHsl(e),hsb:this.toHsb(e)}}},HEX_REGEX_8=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,HEX_REGEX_6=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,RGBA_REGEX=/rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([\d.]+))?\s*\)/i,HSLA_REGEX=/hsla?\(\s*(\d+)\s*,\s*(\d+)%?\s*,\s*(\d+)%?\s*(?:,\s*([\d.]+))?\s*\)/i,ColorParser={fromHex(e){const t=HEX_REGEX_8.exec(e);if(t)return{r:MathUtils.fromHexByte(t[1]),g:MathUtils.fromHexByte(t[2]),b:MathUtils.fromHexByte(t[3]),a:MathUtils.fromHexByte(t[4])};const a=HEX_REGEX_6.exec(e);return a?{r:MathUtils.fromHexByte(a[1]),g:MathUtils.fromHexByte(a[2]),b:MathUtils.fromHexByte(a[3]),a:1}:{r:0,g:0,b:0,a:1}},fromRgb255(e){var t;return{r:e.r/255,g:e.g/255,b:e.b/255,a:null!==(t=e.a)&&void 0!==t?t:1}},fromCss(e){const t=RGBA_REGEX.exec(e);if(t)return{r:parseInt(t[1],10)/255,g:parseInt(t[2],10)/255,b:parseInt(t[3],10)/255,a:void 0!==t[4]?parseFloat(t[4]):1};const a=HSLA_REGEX.exec(e);return a?this.fromHsl({h:parseInt(a[1],10),s:parseInt(a[2],10),l:parseInt(a[3],10),a:void 0!==a[4]?parseFloat(a[4]):1}):{r:0,g:0,b:0,a:1}},fromHsl(e){var t,a;const o=e.h/360,s=e.s/100,i=e.l/100;if(0===s)return{r:i,g:i,b:i,a:null!==(t=e.a)&&void 0!==t?t:1};const hue2rgb=(e,t,a)=>{const o=a<0?a+1:a>1?a-1:a;return o<1/6?e+6*(t-e)*o:o<.5?t:o<2/3?e+(t-e)*(2/3-o)*6:e},r=i<.5?i*(1+s):i+s-i*s,n=2*i-r;return{r:hue2rgb(n,r,o+1/3),g:hue2rgb(n,r,o),b:hue2rgb(n,r,o-1/3),a:null!==(a=e.a)&&void 0!==a?a:1}},fromHsb(e){var t;const a=e.h/360,o=e.s/100,s=e.b/100,i=Math.floor(6*a),r=6*a-i,n=s*(1-o),l=s*(1-r*o),c=s*(1-(1-r)*o),g=[[s,c,n],[l,s,n],[n,s,c],[n,l,s],[c,n,s],[s,n,l]],[d,f,b]=g[i%6];return{r:d,g:f,b:b,a:null!==(t=e.a)&&void 0!==t?t:1}},parse(e){var t;if("object"==typeof e&&null!==e&&"hex"in e&&"rgb"in e)return this.fromHex(e.hex);if("object"==typeof e&&null!==e&&"r"in e&&"g"in e&&"b"in e){const a=e;return a.r<=1&&a.g<=1&&a.b<=1?{r:a.r,g:a.g,b:a.b,a:null!==(t=a.a)&&void 0!==t?t:1}:this.fromRgb255(a)}return"object"==typeof e&&null!==e&&"h"in e&&"s"in e&&"l"in e?this.fromHsl(e):"object"==typeof e&&null!==e&&"h"in e&&"s"in e&&"b"in e?this.fromHsb(e):"string"==typeof e?e.startsWith("rgb")||e.startsWith("hsl")?this.fromCss(e):this.fromHex(e):{r:0,g:0,b:0,a:1}}};class VariableCache{constructor(){this.collectionMap=new Map,this.variableMap=new Map,this.initialized=!1}async initialize(){this.initialized||(await this.rebuild(),this.initialized=!0)}async rebuild(){this.collectionMap.clear(),this.variableMap.clear();for(const e of await figma.variables.getLocalVariableCollectionsAsync()){this.collectionMap.set(e.name,e);for(const t of e.variableIds){const a=await figma.variables.getVariableByIdAsync(t);a&&this.variableMap.set(`${e.name}/${a.name}`,a)}}}getCollection(e){return this.collectionMap.get(e)}getVariable(e){return this.variableMap.get(e)}setVariable(e,t){this.variableMap.set(e,t)}setCollection(e,t){this.collectionMap.set(e,t)}get size(){return this.variableMap.size}get collections(){return this.collectionMap.values()}getVariableKeys(){return Array.from(this.variableMap.keys())}}const variableCache=new VariableCache;function isExportVariableValue(e){return"object"==typeof e&&null!==e&&"$type"in e}function isVariableAlias(e){return"object"==typeof e&&null!==e&&"VARIABLE_ALIAS"===e.type}const TypeMapper={toExportType(e){var t;return null!==(t={COLOR:"color",FLOAT:"float",STRING:"string",BOOLEAN:"boolean"}[e])&&void 0!==t?t:"string"},toFigmaType(e){var t;return null!==(t={color:"COLOR",float:"FLOAT",string:"STRING",boolean:"BOOLEAN"}[e])&&void 0!==t?t:"STRING"},scopesToArray:e=>0===e.length||e.includes("ALL_SCOPES")?["ALL_SCOPES"]:[...e],arrayToScopes:e=>e.includes("ALL_SCOPES")?["ALL_SCOPES"]:e};async function getVariableBindingInfo(e,t){if(!(null==e?void 0:e[t]))return{};const a=e[t];if(!a)return{};const o=await figma.variables.getVariableByIdAsync(a.id);if(!o)return{id:a.id};const s=await figma.variables.getVariableCollectionByIdAsync(o.variableCollectionId);return{id:a.id,name:o.name,collection:null==s?void 0:s.name}}async function extractBindings(e,t){if(!e)return;const a={};for(const o of t){const t=await getVariableBindingInfo(e,o);t.name&&(a[o]=t)}return Object.keys(a).length>0?a:void 0}function flattenVariables(e,t){const a=[];for(const o of Object.keys(e)){const s=e[o],i=t?`${t}/${o}`:o;isExportVariableValue(s)?a.push({path:i,value:s}):a.push(...flattenVariables(s,i))}return a}function getValueAtPath(e,t){const a=t.split("/");let o=e;for(const e of a){if("object"!=typeof o||null===o)return null;if(isExportVariableValue(o))return null;o=o[e]}return isExportVariableValue(o)?o:null}const ColorStyleProcessor={async export(){var e;const t=[];for(const a of await figma.getLocalPaintStylesAsync()){if(0===a.paints.length)continue;const o=a.paints[0];if("SOLID"!==o.type)continue;const s=o.color;let i=null!==(e=o.opacity)&&void 0!==e?e:1;void 0!==s.a&&s.a<1&&1===i&&(i=s.a);const r={r:o.color.r,g:o.color.g,b:o.color.b,a:i},n=Object.assign(Object.assign({name:a.name,color:ColorConverter.toAllFormats(r),opacity:MathUtils.round2(i)},a.description&&{description:a.description}),{boundVariables:await extractBindings(o.boundVariables,["color"])});t.push(n)}return t},async importStyles(e,t){var a;let o=0,s=0;const i=new Map;for(const e of await figma.getLocalPaintStylesAsync())i.set(e.name,e);for(const r of e){let e;i.has(r.name)?(e=i.get(r.name),s++):(e=figma.createPaintStyle(),e.name=r.name,o++),r.description&&(e.description=r.description);const n=ColorParser.parse(r.color);let l=null!==(a=r.opacity)&&void 0!==a?a:1;n.a<1&&void 0===r.opacity&&(l=MathUtils.round2(n.a));let c={type:"SOLID",color:{r:n.r,g:n.g,b:n.b},opacity:MathUtils.round2(l)};if(r.boundVariables)for(const[e,a]of Object.entries(r.boundVariables))if(a.name&&a.collection){const o=t.getVariable(`${a.collection}/${a.name}`);if(o)try{c=figma.variables.setBoundVariableForPaint(c,e,o)}catch(t){Logger.log(`‚ö†Ô∏è Could not bind ${e}: ${t}`)}}e.paints=[c]}return{created:o,updated:s}}},TextStyleProcessor={async export(){const e=[];for(const t of await figma.getLocalTextStylesAsync()){const a=Object.assign(Object.assign({name:t.name,fontFamily:t.fontName.family,fontStyle:t.fontName.style,fontSize:t.fontSize,lineHeight:t.lineHeight,letterSpacing:t.letterSpacing,textCase:t.textCase,textDecoration:t.textDecoration},t.description&&{description:t.description}),{boundVariables:await extractBindings(t.boundVariables,["fontSize","lineHeight","letterSpacing","paragraphSpacing","paragraphIndent"])});e.push(a)}return e},async importStyles(e,t){let a=0,o=0;const s=new Map;for(const e of await figma.getLocalTextStylesAsync())s.set(e.name,e);for(const i of e){let e;s.has(i.name)?(e=s.get(i.name),o++):(e=figma.createTextStyle(),e.name=i.name,a++),i.description&&(e.description=i.description);try{if(await figma.loadFontAsync({family:i.fontFamily,style:i.fontStyle}),e.fontName={family:i.fontFamily,style:i.fontStyle},e.fontSize=i.fontSize,e.lineHeight=i.lineHeight,e.letterSpacing=i.letterSpacing,i.textCase&&(e.textCase=i.textCase),i.textDecoration&&(e.textDecoration=i.textDecoration),i.boundVariables)for(const[a,o]of Object.entries(i.boundVariables))if(o.name&&o.collection){const s=t.getVariable(`${o.collection}/${o.name}`);if(s)try{e.setBoundVariable(a,s)}catch(e){}}}catch(e){Logger.log(`‚ö†Ô∏è Could not load font for ${i.name}: ${e}`)}}return{created:a,updated:o}}},EffectStyleProcessor={async export(){const e=[];for(const t of await figma.getLocalEffectStylesAsync()){const a=[];for(const e of t.effects){const t=Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({type:e.type,visible:e.visible},"radius"in e&&{radius:e.radius}),"spread"in e&&{spread:e.spread}),"offset"in e&&{offset:e.offset}),"color"in e&&{color:ColorConverter.toAllFormats(e.color)}),"blendMode"in e&&{blendMode:e.blendMode}),"showShadowBehindNode"in e&&{showShadowBehindNode:e.showShadowBehindNode}),{boundVariables:await extractBindings(e.boundVariables,["color","radius","spread","offsetX","offsetY"])});a.push(t)}const o=Object.assign(Object.assign({name:t.name},t.description&&{description:t.description}),{effects:a});e.push(o)}return e},async importStyles(e,t){let a=0,o=0;const s=new Map;for(const e of await figma.getLocalEffectStylesAsync())s.set(e.name,e);for(const i of e){let e;s.has(i.name)?(e=s.get(i.name),o++):(e=figma.createEffectStyle(),e.name=i.name,a++),i.description&&(e.description=i.description);const r=i.effects.map(e=>{var t;return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({type:e.type,visible:null===(t=e.visible)||void 0===t||t},void 0!==e.radius&&{radius:e.radius}),void 0!==e.spread&&{spread:e.spread}),void 0!==e.offset&&{offset:e.offset}),void 0!==e.color&&{color:(()=>{const t=ColorParser.parse(e.color);return{r:t.r,g:t.g,b:t.b,a:MathUtils.round2(t.a)}})()}),void 0!==e.blendMode&&{blendMode:e.blendMode}),void 0!==e.showShadowBehindNode&&{showShadowBehindNode:e.showShadowBehindNode})});e.effects=r;for(let a=0;a<i.effects.length;a++){const o=i.effects[a];if(o.boundVariables)for(const[s,i]of Object.entries(o.boundVariables))if(i.name&&i.collection){const o=t.getVariable(`${i.collection}/${i.name}`);if(o)try{const t=[...e.effects];t[a]=figma.variables.setBoundVariableForEffect(t[a],s,o),e.effects=t}catch(e){}}}}return{created:a,updated:o}}},GridStyleProcessor={async export(){const e=[];for(const t of await figma.getLocalGridStylesAsync()){const a=[];for(const e of t.layoutGrids){const t=e.color,o=Object.assign(Object.assign(Object.assign({pattern:e.pattern,visible:e.visible,color:ColorConverter.toAllFormats(t)},"GRID"===e.pattern&&{sectionSize:e.sectionSize}),"GRID"!==e.pattern&&Object.assign({alignment:e.alignment,gutterSize:e.gutterSize,count:e.count,offset:e.offset},void 0!==e.sectionSize&&{sectionSize:e.sectionSize})),{boundVariables:await extractBindings(e.boundVariables,["gutterSize","count","offset","sectionSize"])});a.push(o)}const o=Object.assign(Object.assign({name:t.name},t.description&&{description:t.description}),{layoutGrids:a});e.push(o)}return e},async importStyles(e,t){let a=0,o=0;const s=new Map;for(const e of await figma.getLocalGridStylesAsync())s.set(e.name,e);for(const i of e){let e;s.has(i.name)?(e=s.get(i.name),o++):(e=figma.createGridStyle(),e.name=i.name,a++),i.description&&(e.description=i.description);const r=i.layoutGrids.map(e=>{var t,a,o,s,i,r,n;const l=e.color?ColorParser.parse(e.color):{r:1,g:0,b:0,a:.1},c={r:l.r,g:l.g,b:l.b,a:MathUtils.round2(l.a)};if("GRID"===e.pattern)return{pattern:"GRID",sectionSize:null!==(t=e.sectionSize)&&void 0!==t?t:10,visible:!1!==e.visible,color:c};const g=null!==(a=e.alignment)&&void 0!==a?a:"STRETCH",d={pattern:e.pattern,gutterSize:null!==(o=e.gutterSize)&&void 0!==o?o:10,count:null!==(s=e.count)&&void 0!==s?s:5,visible:!1!==e.visible,color:c};if("STRETCH"===g)return Object.assign(Object.assign({},d),{alignment:"STRETCH",offset:null!==(i=e.offset)&&void 0!==i?i:0});if("CENTER"===g)return Object.assign(Object.assign({},d),{alignment:"CENTER",sectionSize:null!==(r=e.sectionSize)&&void 0!==r?r:100});{const t=Object.assign(Object.assign({},d),{alignment:g,offset:null!==(n=e.offset)&&void 0!==n?n:0});return void 0!==e.sectionSize&&(t.sectionSize=e.sectionSize),t}});e.layoutGrids=r;for(let a=0;a<i.layoutGrids.length;a++){const o=i.layoutGrids[a];if(o.boundVariables)for(const[s,i]of Object.entries(o.boundVariables))if(i.name&&i.collection){const o=t.getVariable(`${i.collection}/${i.name}`);if(o)try{const t=[...e.layoutGrids];t[a]=figma.variables.setBoundVariableForLayoutGrid(t[a],s,o),e.layoutGrids=t}catch(e){}}}}return{created:a,updated:o}}};async function exportVariables(e,t){var a,o,s,i,r,n,l,c,g;Logger.log("üì§ Starting export...");try{let d=await figma.variables.getLocalVariableCollectionsAsync();(null==e?void 0:e.length)&&(d=d.filter(t=>e.includes(t.name)),Logger.log(`Filtering to ${d.length} selected collections`));const f=[];let b=0;for(const e of d){Logger.log(`Processing collection: ${e.name}`);const t={[e.name]:{modes:{}}};for(const a of e.modes)t[e.name].modes[a.name]={};for(const o of e.variableIds){const s=await figma.variables.getVariableByIdAsync(o);if(!s)continue;b++;const i=s.name.split("/");for(const o of e.modes){const r=t[e.name].modes[o.name],n=s.valuesByMode[o.modeId];let l=r;for(let e=0;e<i.length-1;e++){const t=i[e];l[t]&&!isExportVariableValue(l[t])||(l[t]={}),l=l[t]}const c=i[i.length-1];let g,d=!1,f="";if(isVariableAlias(n)){const e=await figma.variables.getVariableByIdAsync(n.id);if(e){const t=await figma.variables.getVariableCollectionByIdAsync(e.variableCollectionId);d=!0,f=null!==(a=null==t?void 0:t.name)&&void 0!==a?a:"",g=`{${e.name.replace(/\//g,".")}}`}else g=""}else g="object"==typeof n&&null!==n&&"r"in n?ColorConverter.toAllFormats(n):n;const b=Object.assign(Object.assign({$scopes:TypeMapper.scopesToArray(s.scopes),$type:TypeMapper.toExportType(s.resolvedType),$value:g},s.description&&{$description:s.description}),d&&{$libraryName:"",$collectionName:f});l[c]=b}}f.push(t)}let u=null;t&&(u={},t.colorStyles&&(u.colorStyles=await ColorStyleProcessor.export()),t.textStyles&&(u.textStyles=await TextStyleProcessor.export()),t.effectStyles&&(u.effectStyles=await EffectStyleProcessor.export()),t.gridStyles&&(u.gridStyles=await GridStyleProcessor.export()),Object.keys(u).length>0?f.push({_styles:u}):u=null);const p={collections:d.length,variables:b,styles:u?{color:null!==(s=null===(o=u.colorStyles)||void 0===o?void 0:o.length)&&void 0!==s?s:0,text:null!==(r=null===(i=u.textStyles)||void 0===i?void 0:i.length)&&void 0!==r?r:0,effect:null!==(l=null===(n=u.effectStyles)||void 0===n?void 0:n.length)&&void 0!==l?l:0,grid:null!==(g=null===(c=u.gridStyles)||void 0===c?void 0:c.length)&&void 0!==g?g:0}:null};Logger.log(`‚úÖ Export complete: ${p.collections} collections, ${p.variables} variables`),Logger.send("export_complete",{data:JSON.stringify(f,null,2),stats:p})}catch(e){Logger.log(`‚ùå Export error: ${e}`),Logger.send("error",{message:`Export failed: ${e}`})}}async function importVariables(e,t){Logger.log("üì• Starting import...");try{const a=JSON.parse(e);await variableCache.initialize();let o=0,s=0,i=0,r=0,n=0,l=0,c=null;const g=[];for(const e of a){const t=Object.keys(e);1===t.length&&"_styles"===t[0]?c=e._styles:g.push(e)}for(const e of g){const a=Object.keys(e)[0],n=e[a];let l;Logger.log(`Processing collection: ${a}`);const c=variableCache.getCollection(a);if(c){if(!t.merge){Logger.log(`  Skipping existing collection: ${a}`);continue}l=c,Logger.log("  Merging into existing collection")}else l=figma.variables.createVariableCollection(a),variableCache.setCollection(a,l),o++,Logger.log("  Created new collection");const g=Object.keys(n.modes),d=new Map;for(const e of l.modes)d.set(e.name,e.modeId);1!==l.modes.length||d.has(g[0])||(l.renameMode(l.modes[0].modeId,g[0]),d.set(g[0],l.modes[0].modeId));for(const e of g)if(!d.has(e))try{const t=l.addMode(e);d.set(e,t)}catch(t){Logger.log(`  ‚ö†Ô∏è Could not create mode ${e}: ${t}`)}const f=flattenVariables(n.modes[g[0]],"");for(const{path:e,value:o}of f){const c=`${a}/${e}`;let f;const b=variableCache.getVariable(c);if(b){if(!t.overwrite){r++;continue}f=b,i++}else try{f=figma.variables.createVariable(e,l,TypeMapper.toFigmaType(o.$type)),s++}catch(t){Logger.log(`  ‚ö†Ô∏è Could not create variable ${e}: ${t}`);continue}o.$description&&(f.description=o.$description);try{f.scopes=TypeMapper.arrayToScopes(o.$scopes)}catch(e){}for(const t of g){const o=d.get(t);if(!o)continue;const s=getValueAtPath(n.modes[t],e);if(s)if("string"==typeof s.$value&&s.$value.startsWith("{")){const e=s.$value.slice(1,-1).replace(/\./g,"/"),t=s.$collectionName||a,i=variableCache.getVariable(`${t}/${e}`);if(i)try{f.setValueForMode(o,{type:"VARIABLE_ALIAS",id:i.id})}catch(e){setRawValue(f,o,s)}else setRawValue(f,o,s)}else setRawValue(f,o,s)}variableCache.setVariable(c,f)}}if(c&&t.importStyles){if(Logger.log("üì¶ Importing styles..."),await variableCache.rebuild(),c.colorStyles){const e=await ColorStyleProcessor.importStyles(c.colorStyles,variableCache);n+=e.created,l+=e.updated}if(c.textStyles){const e=await TextStyleProcessor.importStyles(c.textStyles,variableCache);n+=e.created,l+=e.updated}if(c.effectStyles){const e=await EffectStyleProcessor.importStyles(c.effectStyles,variableCache);n+=e.created,l+=e.updated}if(c.gridStyles){const e=await GridStyleProcessor.importStyles(c.gridStyles,variableCache);n+=e.created,l+=e.updated}}const d={collectionsCreated:o,variablesCreated:s,variablesUpdated:i,variablesSkipped:r,stylesCreated:n,stylesUpdated:l};Logger.log("‚úÖ Import complete!"),Logger.send("import_complete",{stats:d})}catch(e){Logger.log(`‚ùå Import error: ${e}`),Logger.send("error",{message:`Import failed: ${e}`})}}function setRawValue(e,t,a){try{if("color"===a.$type){const o=ColorParser.parse(a.$value),s=o.a<1?Object.assign(Object.assign({},o),{a:MathUtils.round2(o.a)}):o;e.setValueForMode(t,s)}else e.setValueForMode(t,a.$value)}catch(e){console.error(`Could not set value: ${e}`)}}async function getCollections(){const e=await figma.variables.getLocalVariableCollectionsAsync(),t=await Promise.all(e.map(async e=>{const t={color:0,float:0,boolean:0,string:0};for(const a of e.variableIds){const e=await figma.variables.getVariableByIdAsync(a);if(e){t[TypeMapper.toExportType(e.resolvedType)]++}}return{id:e.id,name:e.name,modes:e.modes.map(e=>e.name),variableCount:e.variableIds.length,types:t}})),a={colorStyles:(await figma.getLocalPaintStylesAsync()).length,textStyles:(await figma.getLocalTextStylesAsync()).length,effectStyles:(await figma.getLocalEffectStylesAsync()).length,gridStyles:(await figma.getLocalGridStylesAsync()).length};Logger.send("collections",{collections:t,styles:a})}async function getVariablesForCollection(e){const t=(await figma.variables.getLocalVariableCollectionsAsync()).find(t=>t.name===e);if(!t)return void Logger.send("variables",{variables:[]});const a=(await Promise.all(t.variableIds.map(async e=>{const t=await figma.variables.getVariableByIdAsync(e);return t?{name:t.name,type:t.resolvedType}:null}))).filter(Boolean);Logger.send("variables",{variables:a})}async function clearVariables(){Logger.log("üóëÔ∏è Clearing all variables...");try{let e=0,t=0;for(const a of await figma.variables.getLocalVariableCollectionsAsync()){for(const e of a.variableIds){const a=await figma.variables.getVariableByIdAsync(e);a&&(a.remove(),t++)}a.remove(),e++}Logger.log(`‚úÖ Cleared ${e} collections, ${t} variables`),Logger.send("clear_complete",{message:`${e} collections, ${t} variables`})}catch(e){Logger.log(`‚ùå Clear variables error: ${e}`),Logger.send("error",{message:`Failed to clear variables: ${e}`})}}async function clearStyles(){Logger.log("üóëÔ∏è Clearing all styles...");try{let e=0;for(const t of await figma.getLocalPaintStylesAsync())t.remove(),e++;for(const t of await figma.getLocalTextStylesAsync())t.remove(),e++;for(const t of await figma.getLocalEffectStylesAsync())t.remove(),e++;for(const t of await figma.getLocalGridStylesAsync())t.remove(),e++;Logger.log(`‚úÖ Cleared ${e} styles`),Logger.send("clear_complete",{message:`${e} styles`})}catch(e){Logger.log(`‚ùå Clear styles error: ${e}`),Logger.send("error",{message:`Failed to clear styles: ${e}`})}}async function clearAll(){Logger.log("üóëÔ∏è Clearing everything...");try{await clearVariables(),await clearStyles()}catch(e){Logger.log(`‚ùå Clear all error: ${e}`),Logger.send("error",{message:`Failed to clear: ${e}`})}}figma.ui.onmessage=async e=>{switch(e.type){case"export":await exportVariables(e.collections,e.styleOptions);break;case"import":await importVariables(e.data,e.options);break;case"validate_import":try{const t=JSON.parse(e.data),a=e.plan,o=await validateImportAgainstPlan(t,a);Logger.send("validation_result",o)}catch(e){Logger.send("validation_result",{errors:[`Invalid JSON: ${e instanceof Error?e.message:"Parse error"}`],canImport:!1})}break;case"detect_plan":const t=await detectCurrentPlan();Logger.send("plan_detected",t);break;case"clear_variables":await clearVariables();break;case"clear_styles":await clearStyles();break;case"clear_all":await clearAll();break;case"get_collections":await getCollections();break;case"get_variables":await getVariablesForCollection(e.collection);break;case"close":figma.closePlugin()}};